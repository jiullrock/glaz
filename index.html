<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>GLAZ — тренажёр для глаз</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #000000;
    }
    
    /* Оптимизации для мобильных устройств и четкого рендеринга */
    canvas {
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      image-rendering: -webkit-optimize-contrast;
      /* Дополнительные правила для максимальной четкости */
      image-rendering: -webkit-crisp-edges;
      image-rendering: -o-crisp-edges;
      -ms-interpolation-mode: nearest-neighbor;
      /* Отключаем любое сглаживание на уровне шрифтов */
      -webkit-font-smoothing: none;
      -moz-osx-font-smoothing: unset;
      font-smooth: never;
      text-rendering: optimizeSpeed;
    }
    
    /* Дополнительные оптимизации для высокого DPR */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      canvas {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: optimize-contrast;
        image-rendering: crisp-edges;
      }
    }
    
    /* Оптимизации для мобильных устройств */
    @media (max-width: 768px) {
      canvas {
        transform: translateZ(0); /* Аппаратное ускорение */
        backface-visibility: hidden;
        perspective: 1000;
      }
    }
    
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, sans-serif;
      overflow: hidden;
      touch-action: manipulation;
      user-select: none;
    }
    #app {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      transition: background-color 250ms ease;
    }
    @keyframes flickerAnimation {
      0% { background-color: var(--bg); }
      20% { background-color: #004d00; }
      40% { background-color: var(--bg); }
      60% { background-color: #005a00; }
      80% { background-color: #004d00; }
      100% { background-color: var(--bg); }
    }
    #app.green-flicker {
      animation: flickerAnimation 1000ms ease-in-out;
    }
    .symbolWrapper {
      position: absolute;
      will-change: transform;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .symbolWrapper.hidden { display: none; }
    .symbolWrapper svg { shape-rendering: geometricPrecision; }
    .target-circle {
      transition: filter 5000ms ease-in-out, opacity 5000ms ease-in-out;
      filter: blur(7px);
      opacity: 0.5;
    }
    .target-circle.focus {
      filter: blur(0px);
      opacity: 1;
    }
    .hud {
      position: fixed;
      left: 10px; bottom: 10px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.06);
      color: #111;
      backdrop-filter: blur(6px);
      font-size: 14px;
      line-height: 1.25;
      max-width: min(92vw, 520px);
      transition: opacity .25s ease;
    }
    .dark .hud { background: rgba(255,255,255,.08); color: #f5f5f5; }
    .hud small { opacity: .7; }
    .hud .dot { display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; vertical-align:middle; }
    .phase-symbol .dot { background: #2a7; }
    .phase-pause .dot { background: #999; }
    .muteBadge { position: fixed; right: 10px; bottom: 10px; font-size: 14px; opacity: .8; }
    @media (max-width: 600px) {
      .hud { font-size: 12px; padding: 6px 10px; }
    }
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    .intro {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 1000;
      pointer-events: auto;
      color: #ffffff;
      background: linear-gradient(-45deg, #471a6c, #185276, #45457d);
      background-size: 400% 400%;
      animation: gradientAnimation 15s ease infinite;
      font-weight: 700;
      font-size: clamp(28px, 8vw, 96px);
      line-height: 1.1;
      letter-spacing: 0.02em;
      text-align: center;
      opacity: 1;
      transition: opacity .5s ease;
    }
    .intro.hide { opacity: 0; pointer-events: none; }
    .intro-subtitle {
      display: block;
      margin-top: 12px;
      font-weight: 500;
      font-size: clamp(14px, 3vw, 20px);
      opacity: 0.7;
    }
    .intro-modes-text {
      display: block;
      margin-top: 12px;
      font-weight: 500;
      font-size: clamp(12px, 2.5vw, 16px);
      opacity: 0.7;
    }
    .telegram-link {
      font-size: clamp(12px, 2vw, 14px);
      opacity: 0.6;
      margin-top: 20px;
    }
    .telegram-link a {
      color: #dddddd;
      text-decoration: none;
      pointer-events: auto;
    }
    .telegram-link a:hover {
      text-decoration: underline;
      opacity: 1;
    }
    .intro-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    #intro-settings {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 18px 20px;
      font-size: clamp(14px, 3vw, 18px);
      font-weight: 500;
      max-width: 600px;
      margin: 0 auto;
    }
    #intro-settings label {
      white-space: nowrap;
      min-width: 120px;
      justify-content: flex-start;
      text-align: left;
      transition: background-color 0.2s ease;
      flex: 0 0 calc(33.333% - 14px); /* Максимум 3 в ряд */
      padding: 10px 16px;
      border-radius: 8px;
      background-color: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    #intro-settings label:hover {
      background-color: rgba(255, 255, 255, 0.15);
    }
    #intro-settings label:has(input:checked) {
      background-color: rgba(255, 255, 255, 0.2);
    }
    #language-switch {
      opacity: 0.8;
      font-weight: 500;
    }
    #language-switch label {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }
    #language-switch label:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    #language-switch input[type="radio"] {
      width: 14px;
      height: 14px;
    }
 
    @media (min-width: 600px) {
      #intro-settings {
        gap: 20px 24px;
        max-width: 650px;
      }
      #intro-settings label {
        min-width: 140px;
        flex: 0 0 calc(33.333% - 16px);
        justify-content: flex-start;
        text-align: left;
        padding: 12px 18px;
      }
      .intro-subtitle {
        font-size: clamp(16px, 3.5vw, 24px);
      }
      .telegram-link {
        font-size: clamp(11px, 2.2vw, 15px);
        margin-top: 24px;
      }
    }
    
    @media (max-width: 480px) {
      #intro-settings {
        gap: 16px 18px;
        font-size: clamp(12px, 2.8vw, 16px);
        max-width: 400px;
      }
      #intro-settings label {
        min-width: 110px;
        flex: 0 0 calc(50% - 9px);
        justify-content: flex-start;
        text-align: left;
        padding: 8px 14px;
      }
    }
    #intro-settings label, #sound-toggle, #hints-toggle {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #intro-settings input[type="checkbox"], #soundCheckbox, #hintsCheckbox {
      width: 18px;
      height: 18px;
      margin: 0;
      vertical-align: middle;
    }
    #startButton {
      font-size: clamp(18px, 4vw, 24px);
      font-weight: 600;
      color: #000;
      background-color: #fff;
      border: none;
      padding: 12px 32px;
      border-radius: 12px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    #startButton:hover {
      background-color: #f5f5f5;
    }
    .intro a { color: #dddddd; text-decoration: none; pointer-events: auto; opacity: 0.8; }
    .intro a:hover { text-decoration: underline; opacity: 1; }
    
    /* Стили для popup с информацией о тренировке */
    #trainingInfoPopup {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, sans-serif;
    }
    
    #trainingInfoPopup h2 {
      margin-top: 0;
      text-align: center;
      color: #333;
    }
    
    #trainingInfoPopup ul {
      padding-left: 20px;
      margin: 10px 0;
    }
    
    #trainingInfoPopup li {
      margin-bottom: 8px;
    }
    
    #launchTrainerBtn:hover {
      background: #45a049;
    }
    
    @keyframes titleGlow {
      0% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.3); }
      50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.5), 0 0 30px rgba(102, 126, 234, 0.4); }
      100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.3); }
    }
    
    @keyframes textShine {
      0% { background-position: 0% center; }
      100% { background-position: 200% center; }
    }
    
    .main-title {
      background: linear-gradient(to right, #fff, #a9a9ff, #fff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      background-size: 200% auto;
      animation: titleGlow 4s ease-in-out infinite, textShine 3s linear infinite;
    }
    
    #version-number {
      pointer-events: none;
      user-select: none;
      z-index: 1;
    }
    
    @media (max-width: 480px) {
      #version-number {
        font-size: 8px !important;
        bottom: -6px !important;
        right: -8px !important;
      }
      #intro-title {
        font-size: clamp(36px, 9vw, 100px) !important;
      }
      #intro-title .main-title {
        font-size: clamp(40px, 10vw, 110px) !important;
      }
      #intro-title .intro-subtitle {
        font-size: clamp(18px, 4vw, 26px) !important;
      }
      .telegram-link {
        font-size: clamp(13px, 2.5vw, 16px) !important;
      }
    }
    
    #backToStartBtn {
      font-family: inherit;
    }
    
    @media (max-width: 600px) {
      #backToStartBtn {
        font-size: 12px !important;
        padding: 10px 20px !important;
        bottom: 5% !important;
      }
    }
    
    @keyframes countdownPulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    #countdownContainer {
      font-family: inherit;
    }
    
    #countdownDisplay {
      font-size: 48px;
      font-weight: 700;
      color: #4ade80;
      text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
      margin-top: 8px;
    }
    
    #autoContinueCheckbox {
      width: 16px;
      height: 16px;
      margin-right: 8px;
    }
    
    @media (max-width: 600px) {
      #countdownDisplay {
        font-size: 36px !important;
      }
      
      #autoContinueCheckbox {
        width: 14px !important;
        height: 14px !important;
      }
    }
    
    .centerOverlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      z-index: 1200;
      pointer-events: none;
      color: var(--fg);
    }
    .centerOverlay .title.small { font-size: clamp(14px, 2.6vw, 20px); font-weight: 600; opacity: 0.85; }
    .centerOverlay .title.large { font-size: clamp(28px, 6vw, 72px); font-weight: 700; opacity: 0.28; letter-spacing: 0.02em; }
    .centerOverlay .counter { margin-top: 8px; font-size: clamp(48px, 10vw, 160px); font-weight: 800; line-height: 1.0; }
    @keyframes pulseLarge {
      0% { opacity: 0.22; }
      50% { opacity: 0.36; }
      100% { opacity: 0.22; }
    }
    .centerOverlay .pulse-large { animation: pulseLarge 5.5s ease-in-out infinite; }
    .shutters {
      position: fixed;
      inset: 0;
      z-index: 1100;
      pointer-events: none;
    }
    .shutters .top, .shutters .bottom {
      position: absolute;
      left: 0; right: 0;
      background: #000;
      height: 0%;
      transition: height 2000ms ease-in-out;
    }
    .shutters .top { top: 0; }
    .shutters .bottom { bottom: 0; }
    .shutters.active .top { height: 50%; }
    .shutters.active .bottom { height: 50%; }
    .layers {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .layer {
      position: absolute;
      width: 100%;
      height: 100%;
      transition: filter 2500ms ease-in-out, opacity 2500ms ease-in-out, transform 2500ms ease-in-out;
      will-change: filter, transform, opacity;
    }
    .layer .symbolWrapper { position: relative; left: 0; top: 0; }
    .layer.focus { filter: blur(0px); opacity: 1; }
    .layer.unfocus { filter: blur(7px); opacity: 0.85; }
    #layerBack { z-index: 10; }
    #layerMid { z-index: 20; }
    #layerFront { z-index: 30; }
    .focusViz { filter: blur(0px); opacity: 1; transition: filter 2500ms ease-in-out, opacity 2500ms ease-in-out; }
    .unfocusViz { filter: blur(7px); opacity: 0.85; transition: filter 2500ms ease-in-out, opacity 2500ms ease-in-out; }
    .hiddenSoft { opacity: 0 !important; animation: none !important; transition: opacity 3000ms ease-in-out !important; }
    
    /* Стили для меню паузы */
    #pauseOverlay {
      position: fixed;
      inset: 0;
      display: none; /* Изначально скрыто */
      place-items: center;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      z-index: 2000;
      color: white;
      text-align: center;
    }
    .pause-modal {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 30px;
    }
    .pause-modal h2 {
      margin: 0;
      font-size: clamp(32px, 6vw, 48px);
      font-weight: 700;
    }
    .pause-actions {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .pause-actions button {
      font-family: inherit;
      font-size: clamp(16px, 3vw, 20px);
      font-weight: 600;
      color: #000;
      background-color: #eee;
      border: none;
      padding: 12px 28px;
      border-radius: 12px;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    .pause-actions button:hover {
      background-color: #fff;
    }
    .pause-actions button:active {
      transform: scale(0.98);
    }
    
    /* Стили для кнопки паузы */
    #pauseBtn {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 44px;
      height: 44px;
      background-color: rgba(128, 128, 128, 0.15);
      border-radius: 50%;
      cursor: pointer;
      z-index: 1500;
      display: none; /* Скрыто по-умолчанию */
      place-items: center;
      padding: 10px;
      transition: background-color 0.2s ease, opacity 0.2s ease;
      opacity: 0.5;
    }
    #pauseBtn:hover {
      background-color: rgba(128, 128, 128, 0.3);
      opacity: 1;
    }
    #pauseBtn svg {
      width: 100%;
      height: 100%;
      fill: var(--fg); /* Адаптивный цвет иконки */
    }
    
    /* Стили для таймера обратного отсчета */
    #modeCountdownTimer {
      position: fixed;
      bottom: 10px;
      /* Расположение слева от кнопки паузы */
      right: 64px; /* 10px от края + 44px ширина кнопки паузы + 10px отступ */
      height: 44px;
      display: none; /* Скрыто по-умолчанию */
      align-items: center;
      justify-content: center;
      z-index: 1500;
      font-family: monospace;
      font-size: 14px;
      color: var(--fg);
      background-color: rgba(128, 128, 128, 0.15);
      border-radius: 22px; /* Половина высоты для круглых краев */
      padding: 0 12px;
      opacity: 0.7;
      transition: opacity 0.2s ease;
    }
    
    #modeCountdownTimer:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="app" aria-label="GLAZ тренажёр" role="application"></div>
  <div class="hud" id="hud"></div>
  <div class="muteBadge" id="mute"></div>
  <div class="intro" id="intro">
    <div class="intro-content">
      <div id="intro-title" style="line-height: 1.1;">
        <div style="position: relative; display: inline-block; font-size: inherit;">
          <span class="main-title">GLAZ</span>
          <span id="version-number" style="position: absolute; bottom: -8px; right: -12px; font-size: 10px; opacity: 0.4; font-weight: 400;"></span>
        </div>
        <br>
        <small class="intro-subtitle" style="opacity: 0.8;" data-ru="Тренажёр для глаз" data-en="Eye Trainer">Тренажёр для глаз</small>
      </div>
	  <div id="language-switch" style="display: flex; gap: 12px; align-items: center; font-size: 14px;">
        <label style="cursor: pointer;"><input type="radio" name="language" value="ru" checked> Русский</label>
        <label style="cursor: pointer;"><input type="radio" name="language" value="en"> English</label>
      </div>
	  <small class="intro-modes-text" data-ru="Выбранные режимы будут переключаться:" data-en="Selected modes will switch:">Выбранные ниже режимы будут переключаться:</small>
      <div id="intro-settings">
          <label><input type="checkbox" id="modeSymbol" value="symbol" checked><span data-ru="Символы" data-en="Symbols">Символы</span></label>
          <label><input type="checkbox" id="modeTarget" value="target" checked><span data-ru="Мишень" data-en="Target">Мишень</span></label>
          <label><input type="checkbox" id="modeWords" value="words" checked><span data-ru="Слова" data-en="Words">Слова</span></label>
          <label><input type="checkbox" id="modeEmoji" value="emoji" checked><span data-ru="Эмодзи" data-en="Emoji">Эмодзи</span></label>
          <label><input type="checkbox" id="modeDance" value="dance" checked><span data-ru="Танец" data-en="Dance">Танец</span></label>
          <label><input type="checkbox" id="modeStars" value="stars" checked><span data-ru="Звёзды" data-en="Stars">Звёзды</span></label>
      </div>
      <button id="startButton" data-ru="Старт" data-en="Start">Старт</button>
      <label id="sound-toggle" style="font-size: 16px; font-weight: 500;">
        <input type="checkbox" id="soundCheckbox">
        <span data-ru="Включить звук" data-en="Enable sound">Включить звук</span>
      </label>
      <label id="hints-toggle" style="font-size: 16px; font-weight: 500;">
        <input type="checkbox" id="hintsCheckbox" checked>
        <span data-ru="Показывать подсказки" data-en="Show hints">Показывать подсказки</span>
      </label>
      <small class="telegram-link"><a href="https://t.me/glaz_regen" target="_blank" rel="noopener"><span data-ru="Помощь в Telegram" data-en="https://t.me/glaz_regen">Помощь в Telegram</span></a></small>
    </div>
  </div>
  <div class="centerOverlay" id="center"></div>
  <div class="layers" id="layers">
    <div class="layer" id="layerBack"></div>
    <div class="layer" id="layerMid"></div>
    <div class="layer" id="layerFront"></div>
  </div>
  <div class="shutters" id="shutters"><div class="top"></div><div class="bottom"></div></div>
  <div id="pauseOverlay"></div>
  <div id="modeCountdownTimer"></div>
  <div id="pauseBtn" title="Pause">
    <svg viewBox="0 0 100 100">
      <rect x="25" y="25" width="15" height="50" rx="5"></rect>
      <rect x="60" y="25" width="15" height="50" rx="5"></rect>
    </svg>
  </div>

  <!-- Popup for training information and warnings -->
  <div id="trainingInfoPopup" style="position: fixed; inset: 0; display: none; place-items: center; z-index: 1100; background: rgba(0, 0, 0, 0.7);">
    <div style="background: rgba(255, 255, 255, 0.95); color: #000; padding: 30px; border-radius: 20px; max-width: 90vw; max-height: 90vh; overflow-y: auto; width: 500px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);">
      <h2 style="margin-top: 0; text-align: center;" data-ru="Важная информация" data-en="Important Information">Важная информация</h2>
      <div id="trainingInfoContent" style="font-size: 16px; line-height: 1.5;">
        <h3 data-ru="Перед началом тренировки убедитесь:" data-en="Before starting the training, make sure:">
          Перед началом тренировки убедитесь:
        </h3>
        <ul style="padding-left: 20px;">
          <li data-ru="Экран чистый, яркий и без трещин" data-en="The screen is clean, bright and without cracks">
            Экран чистый, яркий и без трещин
          </li>
          <li data-ru="Вы сидите на комфортном расстоянии, чтобы были четко видны все резкие детали режимов" data-en="You are sitting at a comfortable distance where all sharp details of the modes are clearly visible">
            Вы сидите на комфортном расстоянии, чтобы были четко видны все резкие детали режимов
          </li>
        </ul>
        <h3 data-ru="Польза для зрения:" data-en="Benefits for vision:">
          Польза для зрения:
        </h3>
        <ul style="padding-left: 20px;">
          <li data-ru="Для близоруких: тренирует фокусировку на дальнем плане" data-en="For nearsighted people: trains focus on distant objects">
            Для близоруких: тренирует фокусировку на дальнем плане
          </li>
          <li data-ru="Для дальнозорких: тренирует фокусировку на ближнем плане" data-en="For farsighted people: trains focus on close objects">
            Для дальнозорких: тренирует фокусировку на ближнем плане
          </li>
        </ul>
        <h3 data-ru="Предостережения:" data-en="Warnings:">
          Предостережения:
        </h3>
        <ul style="padding-left: 20px;">
          <li data-ru="Не рекомендуется людям с эпилепсией" data-en="Not recommended for people with epilepsy">
            Не рекомендуется людям с эпилепсией
          </li>
          <li data-ru="При дискомфорте стоит перезапустить тренажер и снять галочки с неподходящих режимов" data-en="If you feel discomfort, restart the trainer and uncheck unsuitable modes">
            При дискомфорте стоит перезапустить тренажер и снять галочки с неподходящих режимов
          </li>
        </ul>
        <h3 data-ru="Рекомендации по применению:" data-en="Usage recommendations:">
          Рекомендации по применению:
        </h3>
        <ul style="padding-left: 20px;">
          <li data-ru="Рекомендуется выполнять 3-4 режима по 2-4 минуты каждый, несколько раз в день" data-en="It is recommended to perform 3-4 modes for 2-4 minutes each, several times a day">
            Рекомендуется выполнять 3-4 режима по 2-4 минуты каждый, несколько раз в день
          </li>
          <li data-ru="Упражнения не должны приносить глазам никакого дискомфорта. Если приносит, стоит разобраться в принципе работы или прекратить упражнения" data-en="The exercises should not cause any discomfort to the eyes. If they do, you should understand the principle of operation or stop the exercises">
            Упражнения не должны приносить глазам никакого дискомфорта. Если приносит, стоит разобраться в принципе работы или прекратить упражнения
          </li>
        </ul>
      </div>
      <button id="launchTrainerBtn" style="display: block; margin: 25px auto 0; padding: 12px 30px; background: #4CAF50; color: white; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; transition: background 0.3s;">
        <span data-ru="Запустить тренажёр" data-en="Launch Trainer">Запустить тренажёр</span>
      </button>
    </div>
  </div>

  <script>
  (function() {
    // *** КОНФИГУРАЦИЯ ВЕРСИИ ***
    // Легко изменяемый номер версии, отображаемый на стартовом экране
    const APP_VERSION = 'v1.3.0';
    // *** КОНЕЦ КОНФИГУРАЦИИ ВЕРСИИ ***
    
    const app = document.getElementById('app');
    const hud = document.getElementById('hud');
    const mute = document.getElementById('mute');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const pauseButton = document.getElementById('pauseBtn');

    let audioCtx = null;
    let masterGain = null;
    let tickingInterval = null;
    let phaseTimer = null;
    let freezeTimer = null;
    let shutterTimer = null;
    let counterTimer = null;
    let flickerTimer = null;
    let phaseEndAt = 0;
    let hasStarted = false;
    let currentDrawMs = 0;
    let wakeLock = null;
    let soundEnabled = false; 
    let hintsEnabled = true;
    let autoContinueEnabled = false;
    let animationRunning = false;
    
    let isPaused = false;
    let remainingDurationOnPause = 0;

    let phase = 'pause';
    let symbolWrapper = null;
    let lastSelectedMode = null;
    let currentLanguage = 'ru';
    let autoContinueTimer = null;
    let countdownSeconds = 10;
    let modeSequence = 'random'; // Добавляем переменную для последовательности режимов
    let modeDuration = 2; // Добавляем переменную для длительности режимов (в минутах)
    let showModeCountdown = true; // Добавляем переменную для отображения таймера режима
    let noBreakMode = false; // Добавляем переменную для режима без отдыха

    // Переменные для таймера обратного отсчета активного режима
    let modeCountdownTimer = null;
    let modeCountdownTimerElement = null;
    
    // Инициализация элемента таймера
    modeCountdownTimerElement = document.getElementById('modeCountdownTimer');

    // Функции LocalStorage для сохранения настроек
    function savePreferences() {
      const preferences = {
        language: currentLanguage,
        soundEnabled: soundEnabled,
        hintsEnabled: hintsEnabled,
        autoContinueEnabled: autoContinueEnabled,
        modeSequence: modeSequence, // Добавляем настройку последовательности режимов
        modeDuration: modeDuration, // Добавляем настройку длительности режимов
        showModeCountdown: showModeCountdown, // Добавляем настройку отображения таймера режима
        noBreakMode: noBreakMode, // Добавляем настройку режима без отдыха
        modes: {
          symbol: document.getElementById('modeSymbol').checked,
          target: document.getElementById('modeTarget').checked,
          words: document.getElementById('modeWords').checked,
          emoji: document.getElementById('modeEmoji').checked,
          dance: document.getElementById('modeDance').checked,
          stars: document.getElementById('modeStars').checked
        }
      };
      localStorage.setItem('glazPreferences', JSON.stringify(preferences));
    }

    function loadPreferences() {
      try {
        const saved = localStorage.getItem('glazPreferences');
        if (saved) {
          const preferences = JSON.parse(saved);
          
          // Загрузка языка
          if (preferences.language) {
            currentLanguage = preferences.language;
            const languageRadio = document.querySelector(`input[name="language"][value="${preferences.language}"]`);
            if (languageRadio) languageRadio.checked = true;
            updateLanguage(preferences.language);
          }
          
          // Загрузка настроек звука
          if (typeof preferences.soundEnabled === 'boolean') {
            soundEnabled = preferences.soundEnabled;
            const soundCheckbox = document.getElementById('soundCheckbox');
            if (soundCheckbox) {
              soundCheckbox.checked = soundEnabled;
              // Инициализация аудио, если звук включен
              if (soundEnabled && !audioCtx) {
                initAudio();
              }
            }
          }
          
          // Загрузка настроек подсказок
          if (typeof preferences.hintsEnabled === 'boolean') {
            hintsEnabled = preferences.hintsEnabled;
            const hintsCheckbox = document.getElementById('hintsCheckbox');
            if (hintsCheckbox) {
              hintsCheckbox.checked = hintsEnabled;
            }
          }
          
          // Загрузка настроек автопродолжения
          if (typeof preferences.autoContinueEnabled === 'boolean') {
            autoContinueEnabled = preferences.autoContinueEnabled;
          }
          
          // Загрузка настроек последовательности режимов
          if (preferences.modeSequence) {
            modeSequence = preferences.modeSequence;
          } else {
            modeSequence = 'random'; // По умолчанию случайная последовательность
            // Сохраняем значение по умолчанию
            savePreferences();
          }
          
          // Загрузка настроек длительности режимов
          if (typeof preferences.modeDuration === 'number') {
            modeDuration = preferences.modeDuration;
          } else {
            modeDuration = 2; // По умолчанию 2 минуты
            // Сохраняем значение по умолчанию
            savePreferences();
          }
          
          // Загрузка настроек отображения таймера режима
          if (typeof preferences.showModeCountdown === 'boolean') {
            showModeCountdown = preferences.showModeCountdown;
          } else {
            showModeCountdown = true; // По умолчанию показываем таймер
            // Сохраняем значение по умолчанию
            savePreferences();
          }
          
          // Загрузка настроек режима без отдыха
          if (typeof preferences.noBreakMode === 'boolean') {
            noBreakMode = preferences.noBreakMode;
          } else {
            noBreakMode = false; // По умолчанию режим отдыха включен
            // Сохраняем значение по умолчанию
            savePreferences();
          }
          
          // Загрузка настроек режимов
          if (preferences.modes) {
            Object.entries(preferences.modes).forEach(([mode, checked]) => {
              const checkbox = document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`);
              if (checkbox) checkbox.checked = checked;
            });
          }
        } else {
          // Если настроек нет, сохраняем значения по умолчанию
          savePreferences();
        }
      } catch (e) {
        console.warn('Failed to load preferences:', e);
      }
    }

    // Функциональность переключения языка
    function updateLanguage(lang) {
      currentLanguage = lang;
      document.querySelectorAll('[data-ru][data-en]').forEach(element => {
        if (lang === 'ru') {
          element.textContent = element.getAttribute('data-ru');
        } else {
          element.textContent = element.getAttribute('data-en');
        }
      });
      savePreferences();
    }

    // Функциональность отображения версии
    function updateVersionDisplay() {
      const versionElement = document.getElementById('version-number');
      if (versionElement) {
        versionElement.textContent = APP_VERSION;
      }
    }

    // Функциональность обратного отсчёта автопродолжения
    function startAutoContinueCountdown() {
      if (autoContinueTimer) {
        clearInterval(autoContinueTimer);
        autoContinueTimer = null;
      }
      
      countdownSeconds = 10;
      updateCountdownDisplay();
      
      autoContinueTimer = setInterval(() => {
        countdownSeconds--;
        updateCountdownDisplay();
        
        if (countdownSeconds <= 0) {
          clearInterval(autoContinueTimer);
          autoContinueTimer = null;
          if (phase === 'pause') {
            proceedToNextCycle();
          }
        }
      }, 1000);
    }

    function stopAutoContinueCountdown() {
      if (autoContinueTimer) {
        clearInterval(autoContinueTimer);
        autoContinueTimer = null;
      }
      hideCountdownDisplay();
    }

    function updateCountdownDisplay() {
      const countdownElement = document.getElementById('countdownDisplay');
      if (countdownElement) {
        countdownElement.textContent = countdownSeconds;
        // Добавляем анимацию пульсации на каждый тик
        countdownElement.style.animation = 'none';
        requestAnimationFrame(() => {
          countdownElement.style.animation = 'countdownPulse 0.6s ease-out';
        });
      }
    }

    function hideCountdownDisplay() {
      const countdownContainer = document.getElementById('countdownContainer');
      if (countdownContainer) {
        countdownContainer.style.display = 'none';
      }
    }

    function showCountdownDisplay() {
      const countdownContainer = document.getElementById('countdownContainer');
      if (countdownContainer) {
        countdownContainer.style.display = 'block';
      }
    }

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function randInt(min, max) { return Math.floor(rand(min, max)); }
    function pick(pTrue=0.5) { return Math.random() < pTrue; }

    function initAudio() {
      if (audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.9;
        masterGain.connect(audioCtx.destination);
      } catch (e) { console.warn('Audio init failed', e); }
    }

    function setTheme(isDark) {
      document.documentElement.classList.toggle('dark', isDark);
      document.documentElement.style.setProperty('--bg', isDark ? '#000000' : '#ffffff');
      document.documentElement.style.setProperty('--fg', isDark ? '#ffffff' : '#000000');
      app.style.backgroundColor = isDark ? '#000' : '#fff';
      app.style.color = isDark ? '#fff' : '#000';
    }

    function updateHUD() {
      const isDark = document.documentElement.classList.contains('dark');
      mute.textContent = soundEnabled ? '' : '';
      hud.className = 'hud phase-' + phase;
      hud.innerHTML = ``;
      hud.style.opacity = phase === 'symbol' ? 0.9 : 0.6;
    }

    let currentHintContent = null;
    let isHintVisible = false;
    let hintClickHandler = null;

    function showCycleInfo(modeName) {
      // Проверяем, включены ли подсказки
      if (!hintsEnabled) {
        return;
      }
      
      const modeNames = {
        'symbol': { ru: 'Символы', en: 'Symbols' },
        'target': { ru: 'Мишень', en: 'Target' },
        'words': { ru: 'Слова', en: 'Words' },
        'emoji': { ru: 'Эмодзи', en: 'Emoji' },
        'dance': { ru: 'Танец', en: 'Dance' },
        'stars': { ru: 'Звёзды', en: 'Stars' }
      };
      
      const modeTitle = modeNames[modeName] ? modeNames[modeName][currentLanguage] : modeName;
      const modeLabel = currentLanguage === 'ru' ? `Режим «${modeTitle}»` : `Mode «${modeTitle}»`;
      const recommendation = currentLanguage === 'ru' 
        ? 'Концентрируйся на резких деталях'
        : 'Focus on sharp details';
      
      // Сохраняем содержимое подсказки для дальнейшего использования
      currentHintContent = {
        modeLabel,
        recommendation
      };
      
      // Устанавливаем содержимое HUD и начальное состояние
      hud.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 4px;">${modeLabel}</div>
        <div style="font-size: 12px; opacity: 0.8;">${recommendation}</div>
      `;
      
      // Устанавливаем начальное состояние анимации HUD
      hud.style.opacity = '0';
      hud.style.transform = 'translateX(0)';
      hud.style.transition = 'opacity 0.8s ease, transform 0.8s ease';
      
      // Плавное появление
      requestAnimationFrame(() => {
        hud.style.opacity = '0.9';
        isHintVisible = true;
        
        // Добавляем обработчик клика для переключения подсказки во время тренировки
        addHintClickHandler();
      });
    }

    function toggleHint() {
      if (!currentHintContent || !hintsEnabled) return;
      
      if (isHintVisible) {
        // Скрываем подсказку
        hud.style.transform = 'translateX(-100%)';
        hud.style.opacity = '0';
        isHintVisible = false;
      } else {
        // Показываем подсказку
        hud.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 4px;">${currentHintContent.modeLabel}</div>
          <div style="font-size: 12px; opacity: 0.8;">${currentHintContent.recommendation}</div>
        `;
        hud.style.transform = 'translateX(0)';
        hud.style.opacity = '0.9';
        isHintVisible = true;
      }
    }

    function addHintClickHandler() {
      // Удаляем существующий обработчик, если есть
      removeHintClickHandler();
      
      // Создаем новый обработчик клика для переключения подсказки
      hintClickHandler = function(event) {
        // Обрабатываем клики только во время тренировки (не во время паузы)
        if (phase === 'symbol') {
          event.stopPropagation();
          toggleHint();
        }
      };
      
      // Добавляем обработчик клика как для приложения, так и для HUD
      app.addEventListener('click', hintClickHandler);
      hud.addEventListener('click', hintClickHandler);
    }

    function removeHintClickHandler() {
      if (hintClickHandler) {
        app.removeEventListener('click', hintClickHandler);
        hud.removeEventListener('click', hintClickHandler);
        hintClickHandler = null;
      }
    }

    function playTick() {
      if (!audioCtx || !soundEnabled || phase !== 'symbol') return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(980 + Math.random()*40, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.25, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.10);
      osc.connect(gain).connect(masterGain);
      osc.start(now);
      osc.stop(now + 0.12);
    }

    function playFocusSwitch(layerName) {
      // Звук переключения фокуса отключён - звук используется только в шумовом режиме
      return;
    }

    let continuousNoiseNodes = null;

    function startContinuousNoise() {
      if (!audioCtx || !soundEnabled || continuousNoiseNodes) return;
      
      // Создаём непрерывный белый шум для шумового режима
      const noiseBuffer1 = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
      const noiseBuffer2 = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
      const noiseBuffer3 = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
      
      // Генерируем белый шум для всех трёх слоёв
      const noiseData1 = noiseBuffer1.getChannelData(0);
      const noiseData2 = noiseBuffer2.getChannelData(0);
      const noiseData3 = noiseBuffer3.getChannelData(0);
      for (let i = 0; i < noiseData1.length; i++) {
        noiseData1[i] = (Math.random() * 2 - 1) * 0.3; // Задний слой - тише
        noiseData2[i] = (Math.random() * 2 - 1) * 0.4; // Средний слой - средняя громкость
        noiseData3[i] = (Math.random() * 2 - 1) * 0.2; // Передний слой - тихий, но чёткий
      }
      
      const noiseSource1 = audioCtx.createBufferSource();
      const noiseSource2 = audioCtx.createBufferSource();
      const noiseSource3 = audioCtx.createBufferSource();
      
      noiseSource1.buffer = noiseBuffer1;
      noiseSource2.buffer = noiseBuffer2;
      noiseSource3.buffer = noiseBuffer3;
      
      noiseSource1.loop = true;
      noiseSource2.loop = true;
      noiseSource3.loop = true;
      
      // Фильтры для каждого слоя
      const filter1 = audioCtx.createBiquadFilter();
      const filter2 = audioCtx.createBiquadFilter();
      const filter3 = audioCtx.createBiquadFilter();
      
      // Задний слой - низкочастотный шум
      filter1.type = 'bandpass';
      filter1.frequency.value = 300;
      filter1.Q.value = 2;
      
      // Средний слой - среднечастотный шум
      filter2.type = 'bandpass';
      filter2.frequency.value = 1000;
      filter2.Q.value = 3;
      
      // Передний слой - высокочастотный шум
      filter3.type = 'highpass';
      filter3.frequency.value = 2000;
      filter3.Q.value = 4;
      
      // Регуляторы громкости
      const gain1 = audioCtx.createGain();
      const gain2 = audioCtx.createGain();
      const gain3 = audioCtx.createGain();
      
      gain1.gain.value = 0.15;
      gain2.gain.value = 0.12;
      gain3.gain.value = 0.08;
      
      // Панорамирование для создания пространственного эффекта
      const pan1 = audioCtx.createStereoPanner();
      const pan2 = audioCtx.createStereoPanner();
      const pan3 = audioCtx.createStereoPanner();
      
      pan1.pan.value = -0.3; // Задний слой - слева
      pan2.pan.value = 0;    // Средний слой - по центру
      pan3.pan.value = 0.3;  // Передний слой - справа
      
      // Подключаем аудио граф
      noiseSource1.connect(filter1).connect(gain1).connect(pan1).connect(masterGain);
      noiseSource2.connect(filter2).connect(gain2).connect(pan2).connect(masterGain);
      noiseSource3.connect(filter3).connect(gain3).connect(pan3).connect(masterGain);
      
      // Запускаем все источники шума
      noiseSource1.start();
      noiseSource2.start();
      noiseSource3.start();
      
      // Сохраняем ссылки для очистки
      continuousNoiseNodes = {
        sources: [noiseSource1, noiseSource2, noiseSource3],
        gains: [gain1, gain2, gain3],
        filters: [filter1, filter2, filter3],
        pans: [pan1, pan2, pan3]
      };
    }

    function stopContinuousNoise() {
      if (continuousNoiseNodes) {
        continuousNoiseNodes.sources.forEach(source => {
          try {
            source.stop();
          } catch (e) { /* ignore if already stopped */ }
        });
        continuousNoiseNodes = null;
      }
    }

    function startTicking() {
      stopTicking();
      playTick();
      tickingInterval = setInterval(playTick, 1000);
    }

    function stopTicking() {
      if (tickingInterval) { clearInterval(tickingInterval); tickingInterval = null; }
    }

    function clearSymbol() {
      if (symbolWrapper && symbolWrapper.parentNode) {
        symbolWrapper.parentNode.removeChild(symbolWrapper);
      }
      symbolWrapper = null;
    }

    function clearPhaseTimer() { if (phaseTimer) { clearTimeout(phaseTimer); phaseTimer = null; } }
    function clearFreezeTimer() { if (freezeTimer) { clearTimeout(freezeTimer); freezeTimer = null; } }
    function clearShutterTimer() { if (shutterTimer) { clearTimeout(shutterTimer); shutterTimer = null; } }
    function clearCounterTimer() { if (counterTimer) { clearInterval(counterTimer); counterTimer = null; } }
    function clearFlickerTimer() { if (flickerTimer) { clearTimeout(flickerTimer); flickerTimer = null; } }
    function clearAutoContinueTimer() { if (autoContinueTimer) { clearInterval(autoContinueTimer); autoContinueTimer = null; } }
    
    // Функции для управления таймером обратного отсчета активного режима
    function startModeCountdownTimer(durationMs) {
        // Останавливаем предыдущий таймер, если он есть
        stopModeCountdownTimer();
        
        // Показываем элемент таймера в зависимости от настройки
        if (modeCountdownTimerElement) {
            modeCountdownTimerElement.style.display = showModeCountdown ? 'flex' : 'none';
        }
        
        // Запускаем новый таймер
        let remainingTime = durationMs;
        updateModeCountdownDisplay(remainingTime);
        
        modeCountdownTimer = setInterval(() => {
            remainingTime -= 1000;
            if (remainingTime <= 0) {
                stopModeCountdownTimer();
                if (modeCountdownTimerElement) {
                    modeCountdownTimerElement.style.display = 'none';
                }
            } else {
                updateModeCountdownDisplay(remainingTime);
            }
        }, 1000);
    }
    
    function stopModeCountdownTimer() {
        if (modeCountdownTimer) {
            clearInterval(modeCountdownTimer);
            modeCountdownTimer = null;
        }
        if (modeCountdownTimerElement) {
            modeCountdownTimerElement.style.display = 'none';
        }
    }
    
    function updateModeCountdownDisplay(remainingTimeMs) {
        if (!modeCountdownTimerElement) return;
        
        // Преобразуем миллисекунды в минуты и секунды
        const totalSeconds = Math.ceil(remainingTimeMs / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        
        // Форматируем строку как MM:SS
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        modeCountdownTimerElement.textContent = formattedTime;
    }

    function updateModeCountdownVisibility() {
        if (!modeCountdownTimerElement) return;
        
        // Обновляем отображение таймера режима в зависимости от настройки
        modeCountdownTimerElement.style.display = showModeCountdown ? 'flex' : 'none';
    }

    function clearAllTimersAndLoops() {
        clearPhaseTimer();
        clearFreezeTimer();
        clearShutterTimer();
        clearCounterTimer();
        clearFlickerTimer();
        clearAutoContinueTimer();
        clearFocusTimers();
        clearCounterVisTimers();
        stopTicking();
        stopContinuousNoise();
        animationRunning = false;
        // Останавливаем таймер обратного отсчета режима
        stopModeCountdownTimer();
    }
    
    pauseButton.addEventListener('click', (e) => {
        e.stopPropagation();
        enterPause();
    });

    function enterPause() {
        if (isPaused || phase !== 'symbol') return;
        isPaused = true;
        pauseButton.style.display = 'none';
        
        remainingDurationOnPause = phaseEndAt - performance.now();
        if (remainingDurationOnPause < 0) remainingDurationOnPause = 0;
        
        clearAllTimersAndLoops();

        const texts = {
            ru: {
                title: 'Пауза',
                continue: 'Продолжить',
                next: 'Следующий режим',
                menu: 'В меню',
                modeSequence: 'Порядок режимов:',
                random: 'Случайный',
                sequential: 'Последовательный',
                modeDuration: 'Длительность режимов:',
                minutes: 'мин',
                noBreakMode: 'Чередовать режимы без экрана отдыха'
            },
            en: {
                title: 'Pause',
                continue: 'Continue',
                next: 'Next Mode',
                menu: 'To Menu',
                modeSequence: 'Mode Order:',
                random: 'Random',
                sequential: 'Sequential',
                modeDuration: 'Mode Duration:',
                minutes: 'min',
                noBreakMode: 'No break screen'
            }
        };
        const langTexts = texts[currentLanguage];

        pauseOverlay.innerHTML = `
            <div class="pause-modal">
                <h2>${langTexts.title}</h2>
                <div class="pause-actions">
                    <div style="margin-bottom: 15px; text-align: center;">
                        <div style="margin-bottom: 8px; font-weight: 600;">${langTexts.modeSequence}</div>
                        <div style="display: flex; gap: 15px; justify-content: center;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="modeSequence" value="random" ${modeSequence === 'random' ? 'checked' : ''} style="margin-right: 6px;">
                                ${langTexts.random}
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="modeSequence" value="sequential" ${modeSequence === 'sequential' ? 'checked' : ''} style="margin-right: 6px;">
                                ${langTexts.sequential}
                            </label>
                        </div>
                    </div>
                    <div style="margin-bottom: 15px; text-align: center;">
                        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px; margin-bottom: 15px;">
                            <input type="checkbox" id="noBreakModeCheckbox" ${noBreakMode ? 'checked' : ''} style="margin-right: 6px;">
                            <span data-ru="${langTexts.noBreakMode}" data-en="${langTexts.noBreakMode}">${langTexts.noBreakMode}</span>
                        </label>
                        <div style="margin-top: 20px; margin-bottom: 8px; font-weight: 600;">${langTexts.modeDuration}</div>
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            ${[2, 4, 6, 8, 10].map(minutes => `
                                <label style="display: flex; align-items: center; cursor: pointer; padding: 6px 12px; background: ${modeDuration === minutes ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.1)'}; border-radius: 6px; transition: background 0.2s ease;">
                                    <input type="radio" name="modeDuration" value="${minutes}" ${modeDuration === minutes ? 'checked' : ''} style="margin-right: 6px;">
                                    ${minutes} ${langTexts.minutes}
                                </label>
                            `).join('')}
                        </div>
                    </div>
                    <div style="margin-bottom: 20px; text-align: center;">
                        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="showModeCountdownCheckbox" ${showModeCountdown ? 'checked' : ''} style="margin-right: 6px;">
                            <span data-ru="Показывать таймер до конца режима" data-en="Show timer">Показывать таймер до конца режима</span>
                        </label>
                    </div>
                    <button id="resumeBtn">${langTexts.continue}</button>
                    <button id="nextModeBtn">${langTexts.next}</button>
                    <button id="toMenuBtn">${langTexts.menu}</button>
                </div>
            </div>
        `;
        pauseOverlay.style.display = 'grid';
        
        // Обновляем язык для динамически созданных элементов
        updateLanguage(currentLanguage);

        // Добавляем обработчик для переключателя последовательности режимов
        const modeSequenceRadios = document.querySelectorAll('input[name="modeSequence"]');
        modeSequenceRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                modeSequence = e.target.value;
                savePreferences(); // Сохраняем настройку сразу при изменении
            });
        });

        // Добавляем обработчик для переключателя длительности режимов
        const modeDurationRadios = document.querySelectorAll('input[name="modeDuration"]');
        modeDurationRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                modeDuration = parseInt(e.target.value);
                savePreferences(); // Сохраняем настройку сразу при изменении
                
                // Обновляем визуальное выделение выбранной длительности
                document.querySelectorAll('input[name="modeDuration"]').forEach(r => {
                    const label = r.parentElement;
                    if (r.checked) {
                        label.style.background = 'rgba(255, 255, 255, 0.2)';
                    } else {
                        label.style.background = 'rgba(255, 255, 255, 0.1)';
                    }
                });
            });
        });

        // Добавляем обработчик для чекбокса отображения таймера режима
        const showModeCountdownCheckbox = document.getElementById('showModeCountdownCheckbox');
        if (showModeCountdownCheckbox) {
            showModeCountdownCheckbox.addEventListener('change', (e) => {
                showModeCountdown = e.target.checked;
                savePreferences(); // Сохраняем настройку сразу при изменении
                
                // Обновляем отображение таймера режима
                updateModeCountdownVisibility();
            });
        }

        // Добавляем обработчик для чекбокса режима без отдыха
        const noBreakModeCheckbox = document.getElementById('noBreakModeCheckbox');
        if (noBreakModeCheckbox) {
            noBreakModeCheckbox.addEventListener('change', (e) => {
                noBreakMode = e.target.checked;
                savePreferences(); // Сохраняем настройку сразу при изменении
            });
        }

        document.getElementById('resumeBtn').addEventListener('click', exitPause);
        document.getElementById('nextModeBtn').addEventListener('click', () => {
            pauseOverlay.style.display = 'none';
            isPaused = false;
            showSymbol(); // This will use the updated modeDuration
        });
        document.getElementById('toMenuBtn').addEventListener('click', () => window.location.reload());
    }

    function exitPause() {
        if (!isPaused) return;
        isPaused = false;
        pauseOverlay.style.display = 'none';
        pauseButton.style.display = 'grid';
        
        // Перезапускаем текущий режим с новой длительностью
        const newDurationMs = modeDuration * 60 * 1000;
        switch (lastSelectedMode) {
            case 'symbol': renderSymbolFor(newDurationMs); break;
            case 'target': renderTargetMode(newDurationMs); break;
            case 'words': renderWordsMode(newDurationMs); break;
            case 'emoji': renderEmojiMode(newDurationMs); break;
            case 'dance': renderDanceMode(newDurationMs); break;
            case 'stars': renderStarsMode(newDurationMs); break;
            default: startPause(); // Если что-то пошло не так
        }
    }

    function clearFocusTimers() {
      if (window._focusTimers && Array.isArray(window._focusTimers)) {
        window._focusTimers.forEach(t => clearTimeout(t));
        window._focusTimers.forEach(t => clearInterval(t));
      }
      window._focusTimers = [];
    }
    function clearCounterVisTimers() {
      if (window._counterVisTimers && Array.isArray(window._counterVisTimers)) {
        window._counterVisTimers.forEach(t => clearTimeout(t));
      }
      window._counterVisTimers = [];
    }
    function clearLayers() {
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => {
        if (!el) return;
        el.innerHTML = '';
        el.classList.remove('focus', 'unfocus');
      });
    }

    function triggerGreenFlicker() {
        const app = document.getElementById('app');
        if (!app) return;
        app.classList.add('green-flicker');
        setTimeout(() => {
            app.classList.remove('green-flicker');
        }, 1000);
    }

    function applyDrawAnimation(el, durationMs, delayMs) {
      try {
        const length = el.getTotalLength();
        const lenStr = length.toFixed(1);
        el.style.strokeDasharray = `${lenStr} ${lenStr}`;
        el.style.strokeDashoffset = lenStr;
        const durMs = Math.max(300, Math.floor(durationMs || 1000));
        const delMs = Math.max(0, Math.floor(delayMs || 0));
        el.style.transition = 'none';
        el.style.willChange = 'stroke-dashoffset';
        void el.getBoundingClientRect();
        requestAnimationFrame(() => {
          el.style.transitionProperty = 'stroke-dashoffset';
          el.style.transitionTimingFunction = 'linear';
          el.style.transitionDuration = `${durMs}ms`;
          el.style.transitionDelay = `${delMs}ms`;
          requestAnimationFrame(() => {
            if (!el.isConnected) return;
            el.style.strokeDashoffset = '0';
            setTimeout(() => {
                if (el.isConnected) {
                    el.style.transition = '';
                }
            }, durMs + delMs);
          });
        });
      } catch (e) {}
    }

    function animateGlyph(svgRoot, durationMs) {
      if (!svgRoot) return;
      const elements = Array.from(svgRoot.querySelectorAll('path, line, polyline, polygon, circle, rect'));
      const total = elements.length || 1;
      elements.forEach((el, i) => {
        const delayMs = Math.floor((i / total) * durationMs);
        const durMs = Math.max(200, durationMs - delayMs);
        applyDrawAnimation(el, durMs, delayMs);
      });
    }

    function createGlyphSVG(sizePx, strokeColor) {
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', sizePx);
      svg.setAttribute('height', sizePx);
      svg.setAttribute('viewBox', '0 0 1000 1000');
      svg.setAttribute('aria-label', 'неизвестный символ');

      const g = document.createElementNS(svgNS, 'g');
      g.setAttribute('fill', 'none');
      g.setAttribute('stroke', strokeColor);
      g.setAttribute('stroke-linecap', 'round');
      g.setAttribute('stroke-linejoin', 'round');

      const base = rand(10, 26);
      const strokes = randInt(6, 13);

      for (let i = 0; i < strokes; i++) {
        const path = document.createElementNS(svgNS, 'path');
        const cx = rand(180, 820), cy = rand(180, 820);
        const r1 = rand(60, 360), r2 = rand(60, 360);
        const a1 = rand(0, Math.PI*2), a2 = a1 + rand(-1.6, 1.6);
        const x1 = cx + Math.cos(a1) * r1, y1 = cy + Math.sin(a1) * r1;
        const x2 = cx + Math.cos(a2) * r2, y2 = cy + Math.sin(a2) * r2;
        const qx = cx + rand(-220, 220), qy = cy + rand(-220, 220);
        const w = base * rand(0.7, 2.2);
        path.setAttribute('d', `M ${x1.toFixed(1)} ${y1.toFixed(1)} Q ${qx.toFixed(1)} ${qy.toFixed(1)} ${x2.toFixed(1)} ${y2.toFixed(1)}`);
        path.setAttribute('stroke-width', w.toFixed(2));
        g.appendChild(path);
      }

      const blobs = randInt(1, 4);
      for (let i = 0; i < blobs; i++) {
        const path = document.createElementNS(svgNS, 'path');
        const cx = rand(200, 800), cy = rand(200, 800);
        const r = rand(40, 180);
        const k = 0.5522847498;
        const ox = r * k * rand(0.7, 1.3), oy = r * k * rand(0.7, 1.3);
        const strokeW = base * rand(0.9, 1.6);
        const d = [`M ${cx - r} ${cy}`, `C ${cx - r} ${cy - oy}, ${cx - ox} ${cy - r}, ${cx} ${cy - r}`, `C ${cx + ox} ${cy - r}, ${cx + r} ${cy - oy}, ${cx + r} ${cy}`, `C ${cx + r} ${cy + oy}, ${cx + ox} ${cy + r}, ${cx} ${cy + r}`, `C ${cx - ox} ${cy + r}, ${cx - r} ${cy + oy}, ${cx - r} ${cy} Z`].join(' ');
        path.setAttribute('d', d);
        path.setAttribute('stroke-width', strokeW.toFixed(2));
        path.setAttribute('fill', 'none');
        g.appendChild(path);
      }

      if (pick(0.35)) {
        const lines = randInt(6, 14);
        for (let i = 0; i < lines; i++) {
          const line = document.createElementNS(svgNS, 'line');
          const ang = rand(0, Math.PI*2), len = rand(100, 600);
          const cx = rand(150, 850), cy = rand(150, 850);
          const x1 = cx - Math.cos(ang) * len/2, y1 = cy - Math.sin(ang) * len/2;
          const x2 = cx + Math.cos(ang) * len/2, y2 = cy + Math.sin(ang) * len/2;
          line.setAttribute('x1', x1.toFixed(1));
          line.setAttribute('y1', y1.toFixed(1));
          line.setAttribute('x2', x2.toFixed(1));
          line.setAttribute('y2', y2.toFixed(1));
          line.setAttribute('stroke-width', (base*rand(0.4,1.2)).toFixed(2));
          line.setAttribute('stroke', strokeColor);
          line.setAttribute('stroke-linecap', 'round');
          g.appendChild(line);
        }
      }

      svg.appendChild(g);
      return svg;
    }

    function mixedLangWord() {
      const ru = 'абвгдеёжзийклмнопрстуфхцчшщьыъэюя';
      const en = 'abcdefghijklmnopqrstuvwxyz';
      const cn = '的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分对成会可主发年动同工也能下过子说产种面而方后多定行学法所民得经十三之进着等部度家电力里如水化高自二理起小物现实加量都两体制机当使点从业本去把性好应开它合还因由其些然前外天政四日那社义事平形相全表间样与关各重新线内数正心反你明看原又么利比或但质气第向道命此变条只没结解问意建月公无系军很情者最立代想已通并提直题党程展五果料象员革位入常文总次品式活设及管特件长求老头基资边流路级少图山统接知较将组见计别她手角期根论运农指几九区强放决西被干做必战先回则任取据处队南给色光门即保治北造百规热领七海口东导器压志世金增争济阶油思术极交受联什认六共权收证改清己美再采转单风切打白教速花带安场身车例真务具万每目至达走积示议声报斗完类八离华名确才科张信马节话米整空元况今集温传土许步群广石记需段研界拉林律叫且究观越织装影算低持音众书布复容儿须际商非验连断深难近矿千周委素技备半办青省列习响约支般史感劳便团往酸历市克何除消构府称太准精값号率族维划选标写存候毛亲快效斯院查江型眼王按格养易置派层片始却专状育厂京识适属圆包火住调满县局照参红细备绿权码';
      let arr = [];
      for (let i = 0; i < randInt(4, 8); i++) {
        arr.push(ru[randInt(0, ru.length)]);
        arr.push(en[randInt(0, en.length)]);
        arr.push(cn[randInt(0, cn.length)]);
      }
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr.slice(0, randInt(4, 10)).join('');
    }

    function renderDanceMode(durationMs) {
      clearAllTimersAndLoops();
      phaseEndAt = performance.now() + durationMs + 2000 + 2000;
      clearSymbol(); updateHUD(); 

      showCycleInfo('dance');
      
      setTheme(false);
      startContinuousNoise();
      animationRunning = true;
      pauseButton.style.display = 'grid';
      // Запускаем таймер обратного отсчета режима
      startModeCountdownTimer(durationMs);

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }
      requestAnimationFrame(() => { if (layersRoot) layersRoot.style.opacity = '1'; });
      
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      const centerX = vw / 2;
      const centerY = vh / 2;
      
      [back, mid, front].forEach(el => {
        if (el) { Array.from(el.querySelectorAll('canvas')).forEach(c => c.remove()); }
      });
      
      function createLayerCanvas(parent) {
        const dpr = window.devicePixelRatio || 1;
        const c = document.createElement('canvas');
        c.width = vw * dpr;
        c.height = vh * dpr;
        c.style.position = 'absolute';
        c.style.left = '0';
        c.style.top = '0';
        c.style.width = `${vw}px`;
        c.style.height = `${vh}px`;
        parent.appendChild(c);
        
        const ctx = c.getContext('2d');
        ctx.scale(dpr, dpr);
        return { canvas: c, ctx };
      }
      
      const canvasLayers = [createLayerCanvas(back), createLayerCanvas(mid), createLayerCanvas(front)];
      const noiseColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#000';
      const dotLayers = [];

      const layerConfigs = [
          { count: 900, minSpeed: 0.3, maxSpeed: 0.9, minSize: 1, maxSize: 2.5 }, // Back
          { count: 300, minSpeed: 0.9, maxSpeed: 1.8, minSize: 1.5, maxSize: 3.5 }, // Mid
          { count: 90,  minSpeed: 1.8, maxSpeed: 3.0, minSize: 2, maxSize: 4.5 }  // Front
      ];

      layerConfigs.forEach(config => {
          const dots = [];
          for (let i = 0; i < config.count; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = rand(config.minSpeed, config.maxSpeed);
              dots.push({
                  baseX: Math.random() * vw,
                  baseY: Math.random() * vh,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  size: rand(config.minSize, config.maxSize),
                  waveAmplitudeX: rand(-15, 15),
                  waveFrequencyX: rand(0.01, 0.05),
                  waveOffsetX: rand(0, Math.PI * 2),
                  waveAmplitudeY: rand(-15, 15),
                  waveFrequencyY: rand(0.01, 0.05),
                  waveOffsetY: rand(0, Math.PI * 2),
                  // Vortex properties
                  inVortex: false,
                  vortexAngle: 0,
                  vortexRadius: 0,
                  vortexSpeed: 0,
                  vortexTargetRadius: 0,
                  vortexStartTime: 0,
                  vortexDuration: 0,
                  // Explosion properties
                  isExploding: false,
                  explosionStartTime: 0,
                  explosionDuration: 0,
                  explosionVx: 0,
                  explosionVy: 0,
                  explosionSpeed: 0,
                  // Smooth acceleration/deceleration properties
                  vortexAcceleration: 0,
                  vortexMaxSpeed: 0
              });
          }
          dotLayers.push(dots);
      });

      // Animation cycle variables
      let lastCycleTime = performance.now();
      const modeStartTime = performance.now(); // Track when this mode started
      const cycleDuration = 60000; // 60 seconds total cycle (minimum 1 minute between vortex phases)
      const explosionDuration = 2000; // 2 seconds explosion
      const vortexDuration = 20000; // 20 seconds vortex
      let animationCycleActive = false;
      let cycleSchedulerTimer = null;

      // Calculate how many complete cycles can fit in the mode duration
      // and adjust timing to avoid ending during vortex
      function calculateSafeCycleStart() {
          const remainingTime = durationMs;
          const completeCycles = Math.floor(remainingTime / cycleDuration);
          
          if (completeCycles < 1) {
              // If less than one complete cycle fits, don't start any cycles
              return null;
          }
          
          // Start first cycle after exactly 1 minute (60 seconds) from mode start
          const firstCycleDelay = 60000; // 1 minute delay for first vortex
          const timeNeededForFirstCycle = firstCycleDelay + cycleDuration;
          
          if (remainingTime < timeNeededForFirstCycle) {
              // Not enough time for even the first cycle with proper delay
              return null;
          }
          
          return firstCycleDelay;
      }

      // Schedule animation cycles with safe timing
      function scheduleAnimationCycles() {
          if (!animationRunning) return;
          
          const safeStartDelay = calculateSafeCycleStart();
          if (safeStartDelay === null) {
              // Not enough time for complete cycles, skip animation cycles
              return;
          }
          
          // Clear any existing scheduler
          if (cycleSchedulerTimer) {
              clearTimeout(cycleSchedulerTimer);
              cycleSchedulerTimer = null;
          }
          
          // Schedule first cycle (with 1-minute delay)
          cycleSchedulerTimer = setTimeout(() => {
              if (!animationRunning) return;
              
              startAnimationCycle();
              
              // Schedule subsequent cycles (every 60 seconds)
              function scheduleNext() {
                  if (!animationRunning) return;
                  
                  const now = performance.now();
                  const elapsedTime = now - modeStartTime;
                  const timeLeft = durationMs - elapsedTime;
                  const timeNeededForCompleteCycle = cycleDuration + 5000; // Add buffer
                  
                  if (timeLeft >= timeNeededForCompleteCycle) {
                      cycleSchedulerTimer = setTimeout(() => {
                          if (!animationRunning) return;
                          startAnimationCycle();
                          scheduleNext(); // Schedule the next cycle
                      }, cycleDuration);
                  }
              }
              
              scheduleNext();
          }, safeStartDelay);
          
          // Store timer for cleanup
          if (cycleSchedulerTimer) {
              window._focusTimers.push(cycleSchedulerTimer);
          }
      }
      
      function startAnimationCycle() {
          if (animationCycleActive) return; // Don't start if already active
      
          animationCycleActive = true;
      
          // Apply vortex effect to all particles
          dotLayers.forEach((dots, layerIndex) => {
              const layerIntensity = [0.7, 0.85, 1.0][layerIndex]; // Back, Mid, Front
              dots.forEach(dot => {
                  // All particles participate in the vortex
                  dot.inVortex = true;
                  dot.vortexStartTime = performance.now();
                  dot.vortexDuration = vortexDuration;
                  dot.vortexAngle = Math.atan2(dot.baseY - centerY, dot.baseX - centerX);
                  dot.vortexRadius = Math.sqrt(Math.pow(dot.baseX - centerX, 2) + Math.pow(dot.baseY - centerY, 2));
                  // Make target radius more varied to prevent clustering
                  dot.vortexTargetRadius = Math.random() * Math.min(vw, vh) * 0.3 * layerIntensity;
                  dot.vortexMaxSpeed = (0.04 + Math.random() * 0.1) * layerIntensity;
                  dot.vortexAcceleration = dot.vortexMaxSpeed / (dot.vortexDuration * 0.2);
                  dot.vortexSpeed = 0;
              });
          });
      
          // For the first 17 seconds of vortex, allow random focus switching
          setFocus(focusNames[randInt(0, 3)]);
          
          // Schedule focus changes during the first 17 seconds of vortex
          const focusSwitchInterval = 2000; // Switch focus every 2 seconds
          let focusSwitchCount = 0;
          const maxFocusSwitches = Math.floor(17000 / focusSwitchInterval); // 17 seconds / 2 seconds = 8-9 switches
          
          const focusSwitchTimer = setInterval(() => {
              if (focusSwitchCount < maxFocusSwitches) {
                  setFocus(focusNames[randInt(0, 3)]);
                  focusSwitchCount++;
              }
          }, focusSwitchInterval);
          
          window._focusTimers.push(focusSwitchTimer);
          
          // At 17 seconds into vortex (3 seconds before explosion), fix focus on back layer
          const fixFocusTimer = setTimeout(() => {
              setFocus('back');
          }, 17000);
          
          window._focusTimers.push(fixFocusTimer);
      
          // End vortex and trigger explosion after 20 seconds
          const endVortexTimer = setTimeout(() => {
              // Trigger explosion
              dotLayers.forEach((dots, layerIndex) => {
                  const layerIntensity = [1.0, 1.5, 2.0][layerIndex]; // Back, Mid, Front
                  dots.forEach(dot => {
                      // Exit vortex state
                      dot.inVortex = false;
                      
                      // Set explosion properties
                      dot.isExploding = true;
                      dot.explosionStartTime = performance.now();
                      dot.explosionDuration = explosionDuration;
                      
                      // Calculate explosion direction away from center
                      const angle = Math.atan2(dot.baseY - centerY, dot.baseX - centerX);
                      const speed = (3 + Math.random() * 5) * layerIntensity;
                      dot.explosionVx = Math.cos(angle) * speed;
                      dot.explosionVy = Math.sin(angle) * speed;
                  });
          });
          
          // Set focus to random layer after vortex ends (beginning of explosion)
          setFocus(focusNames[randInt(0, 3)]);
          
          // End explosion and return to normal movement
          const endExplosionTimer = setTimeout(() => {
              dotLayers.forEach(dots => {
                  dots.forEach(dot => {
                      if (dot.isExploding) {
                          dot.isExploding = false;
                          
                          // Give new random direction when exiting explosion
                          const angle = Math.random() * Math.PI * 2;
                          const speed = rand(layerConfigs[dotLayers.indexOf(dots)].minSpeed, layerConfigs[dotLayers.indexOf(dots)].maxSpeed);
                          dot.vx = Math.cos(angle) * speed;
                          dot.vy = Math.sin(angle) * speed;
                      }
                  });
              });
              
              // After explosion ends, particles fly chaotically for 20 seconds
              // Resume normal random focus switching immediately
              animationCycleActive = false;
              
              const chaoticMovementTimer = setTimeout(() => {
                  // Mark cycle as complete and update last cycle time
                  lastCycleTime = performance.now();
              }, 20000); // 20 seconds of chaotic movement
              
              window._focusTimers.push(chaoticMovementTimer);
          }, explosionDuration);
          
          window._focusTimers.push(endExplosionTimer);
      }, vortexDuration);
      
      window._focusTimers.push(endVortexTimer);
  }

  function animateDance() {
    if (!animationRunning) return;

    const currentTime = performance.now();
    
    canvasLayers.forEach((layer, index) => {
        const ctx = layer.ctx;
        const dots = dotLayers[index];

        ctx.clearRect(0, 0, vw, vh);
        ctx.fillStyle = noiseColor;

        dots.forEach(dot => {
            // Handle explosion effect
            if (dot.isExploding) {
                const elapsed = currentTime - dot.explosionStartTime;
                const progress = Math.min(1, elapsed / dot.explosionDuration);
                
                // Move particle in explosion direction
                const speedFactor = 1 - progress; // Slow down as explosion ends
                dot.baseX += dot.explosionVx * speedFactor;
                dot.baseY += dot.explosionVy * speedFactor;
                
                // Handle screen boundaries during explosion
                if (dot.baseX < 0) dot.baseX = vw;
                if (dot.baseX > vw) dot.baseX = 0;
                if (dot.baseY < 0) dot.baseY = vh;
                if (dot.baseY > vh) dot.baseY = 0;
            }
            // Handle vortex effect with smooth acceleration and deceleration
            else if (dot.inVortex) {
                const elapsed = currentTime - dot.vortexStartTime;
                const progress = Math.min(1, elapsed / dot.vortexDuration);
                
                // Smooth acceleration and deceleration curve for even smoother movement
                let speedFactor;
                if (progress < 0.2) {
                    // Acceleration phase (first 20% of vortex)
                    speedFactor = progress * 5; // 0 to 1
                } else if (progress > 0.8) {
                    // Deceleration phase (last 20% of vortex)
                    speedFactor = 1 - (progress - 0.8) * 5; // 1 to 0
                } else {
                    // Full speed phase (middle 60% of vortex)
                    speedFactor = 1;
                }
                
                // Apply acceleration to speed for smoother transitions
                if (progress < 0.2) {
                    dot.vortexSpeed = Math.min(dot.vortexMaxSpeed, dot.vortexSpeed + dot.vortexAcceleration);
                } else if (progress > 0.8) {
                    dot.vortexSpeed = Math.max(0, dot.vortexSpeed - dot.vortexAcceleration);
                }
                
                if (progress >= 1) {
                    // Exit vortex
                    dot.inVortex = false;
                    // Particles should continue from their current position
                    // Give new random direction when exiting with normal speed
                    const angle = Math.random() * Math.PI * 2;
                    const speed = rand(layerConfigs[index].minSpeed, layerConfigs[index].maxSpeed); // Normal speed
                    dot.vx = Math.cos(angle) * speed;
                    dot.vy = Math.sin(angle) * speed;
                    dot.vortexSpeed = 0;
                } else {
                    // Update vortex position with smooth speed
                    // Spiral inward toward center with enhanced smoothness and doubled speed during vortex
                    const currentRadius = dot.vortexRadius + (dot.vortexTargetRadius - dot.vortexRadius) * progress;
                    dot.vortexAngle += dot.vortexSpeed * speedFactor * 2; // Doubled rotation speed during vortex for more dynamic effect
                    
                    dot.baseX = centerX + Math.cos(dot.vortexAngle) * currentRadius;
                    dot.baseY = centerY + Math.sin(dot.vortexAngle) * currentRadius;
                }
            } else {
                // Normal movement with normal speed (no change)
                dot.baseX += dot.vx;
                dot.baseY += dot.vy;

                if (dot.baseX < 0) dot.baseX = vw;
                if (dot.baseX > vw) dot.baseX = 0;
                if (dot.baseY < 0) dot.baseY = vh;
                if (dot.baseY > vh) dot.baseY = 0;
            }

            const waveX = dot.waveAmplitudeX * Math.sin(dot.baseY * dot.waveFrequencyX + dot.waveOffsetX);
            const waveY = dot.waveAmplitudeY * Math.sin(dot.baseX * dot.waveFrequencyY + dot.waveOffsetY);
            
            const finalX = dot.baseX + waveX;
            const finalY = dot.baseY + waveY;

            ctx.beginPath();
            ctx.arc(finalX, finalY, dot.size / 2, 0, Math.PI * 2);
            ctx.fill();
        });
    });

    requestAnimationFrame(animateDance);
}

// Start scheduling animation cycles
scheduleAnimationCycles();

// Start animation loop
animateDance();

function setFocus(target) {
const map = { back, mid, front };
Object.entries(map).forEach(([key, el]) => {
  if (!el) return;
  if (key === target) {
    el.classList.add('focus');
    el.classList.remove('unfocus');
    playFocusSwitch(target);
  } else {
    el.classList.add('unfocus');
    el.classList.remove('focus');
  }
});
const center = document.getElementById('center');
if (center) {
  center.classList.toggle('focusViz', target === 'mid');
  center.classList.toggle('unfocusViz', target !== 'mid');
}
}

setFocus('mid');

const focusNames = ['mid', 'back', 'front'];
const nSwitches = Math.max(3, Math.floor(durationMs / 2000));
let lastFocus = 'mid';
const switchTimers = [];
for (let i = 0; i < nSwitches; i++) {
  let next;
  do {
    next = focusNames[randInt(0, 3)];
  } while (next === lastFocus);
  const at = Math.floor((i + 1) * durationMs / (nSwitches + 1)) + randInt(-800, 800);
  switchTimers.push(setTimeout(() => {
    // Only allow random focus switching when not in vortex phase
    if (!animationCycleActive) {
      setFocus(next);
      lastFocus = next;
    }
  }, Math.max(0, at)));
  lastFocus = next;
}
window._focusTimers.push(...switchTimers);

const center = document.getElementById('center');
if (center) {
center.classList.remove('unfocusViz');
center.classList.add('focusViz');
center.innerHTML = ``;
}

const shutters = document.getElementById('shutters');
const freezeLead = 2000;
freezeTimer = setTimeout(() => { 
    animationRunning = false;
    // Stop any ongoing animation cycles immediately when mode ends
    animationCycleActive = false;
    if (cycleSchedulerTimer) {
        clearTimeout(cycleSchedulerTimer);
        cycleSchedulerTimer = null;
    }
    stopContinuousNoise();
}, Math.max(0, durationMs));
shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
}

    function renderStarsMode(durationMs) {
      clearAllTimersAndLoops();
      phaseEndAt = performance.now() + durationMs + 2000 + 2000;
      clearSymbol(); updateHUD(); 
      
      showCycleInfo('stars');
      setTheme(false);
      startContinuousNoise();
      pauseButton.style.display = 'grid';
      // Запускаем таймер обратного отсчета режима
      startModeCountdownTimer(durationMs);

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }
      requestAnimationFrame(() => { if (layersRoot) layersRoot.style.opacity = '1'; });
      
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      
      [back, mid, front].forEach(el => {
        if (el) { Array.from(el.querySelectorAll('canvas')).forEach(c => c.remove()); }
      });
      
      function createLayerCanvas(parent) {
        const dpr = window.devicePixelRatio || 1;
        const c = document.createElement('canvas');
        c.width = vw * dpr;
        c.height = vh * dpr;
        c.style.position = 'absolute';
        c.style.left = '0';
        c.style.top = '0';
        c.style.width = `${vw}px`;
        c.style.height = `${vh}px`;
        parent.appendChild(c);
        
        const ctx = c.getContext('2d');
        ctx.scale(dpr, dpr);
        return { canvas: c, ctx };
      }
      
      const layerBack = createLayerCanvas(back);
      const layerMid = createLayerCanvas(mid);
      const layerFront = createLayerCanvas(front);
      
      const isDark = document.documentElement.classList.contains('dark');
      const noiseColor = isDark ? 'white' : 'black';
      
      function generateStarsPattern(ctx, density, dotSize) {
        ctx.clearRect(0, 0, vw, vh);
        ctx.fillStyle = noiseColor;
        
        const numDots = Math.floor((vw * vh) / (density * density));
        for (let i = 0; i < numDots; i++) {
          const x = Math.random() * vw;
          const y = Math.random() * vh;
          const size = dotSize + Math.random() * dotSize;
          
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      const starsConfigs = [
        { density: 15, dotSize: 1.5 },
        { density: 25, dotSize: 2.5 },
        { density: 35, dotSize: 4.0 }
      ];
      
      const layers = [layerBack, layerMid, layerFront];
      
      layers.forEach((layer, idx) => {
        const config = starsConfigs[idx];
        generateStarsPattern(layer.ctx, config.density, config.dotSize);
      });
      
      function setFocus(target) {
        const map = { back, mid, front };
        Object.entries(map).forEach(([key, el]) => {
          if (!el) return;
          if (key === target) {
            el.classList.add('focus');
            el.classList.remove('unfocus');
            playFocusSwitch(target);
          } else {
            el.classList.add('unfocus');
            el.classList.remove('focus');
          }
        });
        const center = document.getElementById('center');
        if (center) {
          center.classList.toggle('focusViz', target === 'mid');
          center.classList.toggle('unfocusViz', target !== 'mid');
        }
      }
      setFocus('mid');

      const focusNames = ['mid', 'back', 'front'];
      const nSwitches = Math.max(3, Math.floor(durationMs / 2000));
      let lastFocus = 'back';
      const switchTimers = [];
      for (let i = 0; i < nSwitches; i++) {
        let next;
        do {
          next = focusNames[randInt(0, 3)];
        } while (next === lastFocus);
        const at = Math.floor((i + 1) * durationMs / (nSwitches + 1)) + randInt(-800, 800);
        switchTimers.push(setTimeout(() => {
          // Only allow random focus switching when not in vortex phase
          if (!animationCycleActive) {
            setFocus(next);
            lastFocus = next;
          }
        }, Math.max(0, at)));
        lastFocus = next;
      }
      window._focusTimers.push(...switchTimers);
      
      const center = document.getElementById('center');
      if (center) {
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        center.innerHTML = ``;
      }
      
      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      freezeTimer = setTimeout(() => { 
          stopContinuousNoise(); 
      }, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }

    function renderWordsMode(durationMs) {
      const startTime = performance.now();
      clearAllTimersAndLoops();
      phaseEndAt = performance.now() + durationMs + 2000 + 2000;
      clearSymbol(); updateHUD(); setTheme(pick(0.5)); startTicking();

      showCycleInfo('words');
      animationRunning = true;
      pauseButton.style.display = 'grid';
      // Запускаем таймер обратного отсчета режима
      startModeCountdownTimer(durationMs);

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }
      requestAnimationFrame(() => { if (layersRoot) layersRoot.style.opacity = '1'; });
      
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      
      [back, mid, front].forEach(el => {
        if (el) { Array.from(el.querySelectorAll('canvas')).forEach(c => c.remove()); }
      });
      
      function createLayerCanvas(parent) {
        const dpr = window.devicePixelRatio || 1;
        const c = document.createElement('canvas');
        c.width = vw * dpr;
        c.height = vh * dpr;
        c.style.position = 'absolute';
        c.style.left = '0';
        c.style.top = '0';
        c.style.width = `${vw}px`;
        c.style.height = `${vh}px`;
        parent.appendChild(c);
        
        const ctx = c.getContext('2d');
        ctx.scale(dpr, dpr);
        return c;
      }
      const canvBack = createLayerCanvas(back);
      const canvMid = createLayerCanvas(mid);
      const canvFront = createLayerCanvas(front);
      
      const nWords = 3; 
      const allWords = [];
      for (let i = 0; i < nWords; i++) {
        const word = mixedLangWord();
        let fontSize;
        if (i === nWords - 1) {
            fontSize = rand(14, 22);
        } else {
            fontSize = rand(48, 120);
        }
        
        const direction = pick(0.5) ? 1 : -1; 
        const y = vh / 2;
        const x0 = vw / 2;
        const moveDistance = rand(vw * 0.1, vw * 0.25); 
        const x1 = vw / 2 + (moveDistance * direction);

        const duration = durationMs;
        const layer = ['back', 'mid', 'front'][i];
        allWords.push({word, fontSize, y, x0, x1, duration, t0: startTime, layer, direction});
      }
      
      const wordsByLayer = {back: [], mid: [], front: []};
      allWords.forEach(w => wordsByLayer[w.layer].push(w));
      
      const isDark = document.documentElement.classList.contains('dark');
      const wordColor = isDark ? '#fff' : '#000';
      
      // Счетчик фокусов на переднем слое
      let frontFocusCount = 0;
      
      function setFocus(target) {
        playFocusSwitch(target);
        const map = { back, mid, front };
        Object.entries(map).forEach(([key, el]) => {
          if (!el) return;
          el.classList.toggle('focus', key === target);
          el.classList.toggle('unfocus', key !== target);
        });
        const center = document.getElementById('center');
        if (center) {
          center.classList.toggle('focusViz', target === 'mid');
          center.classList.toggle('unfocusViz', target !== 'mid');
        }
        
        // Обработка фокуса на переднем слое
        if (target === 'front') {
          frontFocusCount++;
          
          // Если это третий (или более) фокус на переднем слое, меняем эмодзи
          if (frontFocusCount >= 3) {
            // Используем плавный переход при изменении эмодзи
            changeEmojiWithFade('back', getRandomEmoji());
            changeEmojiWithFade('mid', getRandomEmoji());
            changeEmojiWithFade('front', getRandomEmoji());
            
            // Сбрасываем счетчик
            frontFocusCount = 0;
          }
        }
      }
      setFocus('mid');
      
      const focusNames = ['mid', 'back', 'front'];
      const nSwitches = Math.max(1, Math.floor(durationMs / 3000));
      let lastFocus = 'mid';
      const switchTimers = [];
      for (let i = 0; i < nSwitches; i++) {
        let next;
        do {
          next = focusNames[randInt(0, 3)];
        } while (next === lastFocus);
        const at = Math.floor((i + 1) * durationMs / (nSwitches + 1));
        switchTimers.push(setTimeout(() => setFocus(next), at));
        lastFocus = next;
      }
      window._focusTimers.push(...switchTimers);
      
      function drawWords(ctx, words, now) {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.restore();

        words.forEach(w => {
          const p = Math.min(1, (now - w.t0) / w.duration);
          const x = w.x0 + (w.x1 - w.x0) * p;
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.font = `bold ${Math.floor(w.fontSize)}px system-ui, Arial, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = wordColor;
          ctx.fillText(w.word, x, w.y);
          ctx.restore();
        });
      }
      function animate() {
        if (!animationRunning) return;
        const now = performance.now();
        drawWords(canvBack.getContext('2d'), wordsByLayer.back, now);
        drawWords(canvMid.getContext('2d'), wordsByLayer.mid, now);
        drawWords(canvFront.getContext('2d'), wordsByLayer.front, now);
        if (now - startTime < durationMs) {
          requestAnimationFrame(animate);
        }
      }
      animate();
      
      const center = document.getElementById('center');
      if (center) {
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        center.innerHTML = ``;
      }
      
      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      freezeTimer = setTimeout(() => { 
          animationRunning = false;
          stopTicking();
      }, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }
    
    function renderEmojiMode(durationMs) {
      clearAllTimersAndLoops();
      phaseEndAt = performance.now() + durationMs + 2000 + 2000;
      clearSymbol(); updateHUD(); setTheme(pick(0.5)); startTicking();

      showCycleInfo('emoji');
      pauseButton.style.display = 'grid';
      // Запускаем таймер обратного отсчета режима
      startModeCountdownTimer(durationMs);

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }
      requestAnimationFrame(() => { if (layersRoot) layersRoot.style.opacity = '1'; });
      
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      
      [back, mid, front].forEach(el => {
        if (el) { Array.from(el.querySelectorAll('canvas')).forEach(c => c.remove()); }
      });
      
      const emojiSets = [
        ['🌸', '🌺', '🌼', '🌻', '🌷', '🌹', '🥀', '💐', '🌱', '🌿', '☘️', '🍀'],
        ['🌵', '🌴', '🌳', '🌲', '🌾', '🍁', '🍂', '🍃', '🍄', '🌰', '🌍', '🌎'],
        ['🌏', '🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘', '🌙', '🌚', '🌝'],
        ['🌞', '⭐', '🌟', '✨', '⚡', '🔥', '💧', '🌊', '☂️', '🌈', '❄️', '☃️'],
        ['⛄', '🌬️', '💨', '🌪️', '🌫️', '🌌', '🌃', '🌆', '🌇', '🌉', '🌁', '🏞️'],
        ['🌅', '🌄', '🗻', '🏔️', '⛰️', '🌋', '🏝️', '🏜️', '🌐', '🪐', '🌠', '🌌'],
        ['🎇', '🎆', '🕊️', '🦋', '🐚', '🪷', '🍇', '🍒', '🍓', '🍉', '🍊', '🍋'],
        ['🍎', '🍏', '🍑', '🥭', '🍍', '🥥', '🥝', '🥑', '🌽', '🥦', '🥒', '🫘'],
        ['🍵', '🍶', '🍺', '🍷', '🥂', '🍸', '🥤', '🧃', '🍫', '🍩', '🍪', '🍯'],
        ['🕯️', '💡', '🔮', '🪞', '🎨', '🧩', '🎵', '🎶', '🎼', '📚', '🪄', '😺']
      ];
      
      function getRandomEmoji() {
        const randomSet = emojiSets[Math.floor(Math.random() * emojiSets.length)];
        return randomSet[Math.floor(Math.random() * randomSet.length)];
      }
      
      function createLayerCanvas(parent) {
        const dpr = window.devicePixelRatio || 1;
        const superSampleFactor = dpr >= 3 ? 2 : (dpr >= 2 ? 1.5 : 1);
        const effectiveDpr = dpr * superSampleFactor;
        
        const c = document.createElement('canvas');
        c.width = vw * effectiveDpr;
        c.height = vh * effectiveDpr;
        c.style.position = 'absolute';
        c.style.left = '0';
        c.style.top = '0';
        c.style.width = `${vw}px`;
        c.style.height = `${vh}px`;
        c.style.imageRendering = 'pixelated';
        c.style.imageRendering = '-moz-crisp-edges';
        c.style.imageRendering = 'crisp-edges';
        c.style.imageRendering = '-webkit-optimize-contrast';
        c.style.imageRendering = '-webkit-crisp-edges';
        c.style.webkitFontSmoothing = 'none';
        c.style.mozOsxFontSmoothing = 'unset';
        c.style.fontSmooth = 'never';
        c.style.textRendering = 'optimizeSpeed';
        c.style.transformStyle = 'preserve-3d';
        c.style.transform = 'translateZ(0)';
        parent.appendChild(c);
        
        const ctx = c.getContext('2d', {
          alpha: true,
          desynchronized: true,
          powerPreference: 'high-performance'
        });
        ctx.scale(effectiveDpr, effectiveDpr);
        ctx.imageSmoothingEnabled = false;
        if (ctx.textRenderingOptimization) {
          ctx.textRenderingOptimization = 'optimizeSpeed';
        }
        if (ctx.imageSmoothingQuality !== undefined) {
          ctx.imageSmoothingQuality = 'low';
        }
        return c;
      }
      const canvBack = createLayerCanvas(back);
      const canvMid = createLayerCanvas(mid);
      const canvFront = createLayerCanvas(front);
      const emojiSizes = {
        back: 18,   
        mid: 27,    
        front: 54   
      };
      
      let allEmojis = {
        back: getRandomEmoji(),
        mid: getRandomEmoji(),
        front: getRandomEmoji()
      };
      
      // Позиции эмодзи для каждого слоя (начинаем в центре)
      let emojiPositions = {
        back: { x: vw / 2, y: vh / 2 },
        mid: { x: vw / 2, y: vh / 2 },
        front: { x: vw / 2, y: vh / 2 }
      };
      
      // Направление движения для плавной анимации
      let movementDirection = {
        dx: (Math.random() - 0.5) * 2, // От -1 до 1
        dy: (Math.random() - 0.5) * 2  // От -1 до 1
      };
      
      // Нормализуем вектор направления
      const magnitude = Math.sqrt(movementDirection.dx * movementDirection.dx + movementDirection.dy * movementDirection.dy);
      movementDirection.dx /= magnitude;
      movementDirection.dy /= magnitude;
      
      // Скорость движения (пиксели за кадр) - движение отключено
      const movementSpeed = 0;
      
      // Накопители для субпиксельного позиционирования
      let subPixelAccumulator = {
        back: { x: 0, y: 0 },
        mid: { x: 0, y: 0 },
        front: { x: 0, y: 0 }
      };
      
      const canvases = { back: canvBack, mid: canvMid, front: canvFront };
      const isDark = document.documentElement.classList.contains('dark');
      
      function drawEmoji(layer, emoji) {
        const canvas = canvases[layer];
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        ctx.clearRect(0, 0, vw, vh);
        
        ctx.imageSmoothingEnabled = false;
        if (ctx.textRenderingOptimization) {
          ctx.textRenderingOptimization = 'optimizeSpeed';
        }
        if (ctx.imageSmoothingQuality) {
          ctx.imageSmoothingQuality = 'high';
        }
        
        const baseFontSize = emojiSizes[layer];
        const fontSize = dpr >= 2 ? baseFontSize * 1.5 : baseFontSize;
        
        ctx.font = `${fontSize}px "Noto Color Emoji", "Apple Color Emoji", "Segoe UI Emoji", "Android Emoji", EmojiSymbols, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Используем позиции для рисования
        const x = Math.round(emojiPositions[layer].x);
        const y = Math.round(emojiPositions[layer].y);
        ctx.fillText(emoji, x, y);
      }
      
      Object.keys(allEmojis).forEach(layer => {
        drawEmoji(layer, allEmojis[layer]);
      });
      
      // Функция для плавного изменения эмодзи с эффектом fadeout/fadein
      function changeEmojiWithFade(layer, newEmoji) {
        const canvas = canvases[layer];
        const ctx = canvas.getContext('2d');
        
        // Плавное исчезновение старого эмодзи (2.5 секунды)
        let opacity = 1.0;
        const fadeOutDuration = 2500; // 2.5 секунды
        const fadeInDuration = 2500;  // 2.5 секунды
        const fadeOutStep = 1.0 / (fadeOutDuration / 16); // 16ms per frame ~60fps
        const fadeInStep = 1.0 / (fadeInDuration / 16);   // 16ms per frame ~60fps
        
        function fadeOut() {
          if (opacity > 0) {
            ctx.clearRect(0, 0, vw, vh);
            ctx.globalAlpha = opacity;
            drawEmoji(layer, allEmojis[layer]); // Рисуем старый эмодзи с уменьшенной прозрачностью
            opacity -= fadeOutStep;
            requestAnimationFrame(fadeOut);
          } else {
            // После полного исчезновения меняем эмодзи
            allEmojis[layer] = newEmoji;
            fadeIn();
          }
        }
        
        function fadeIn() {
          if (opacity < 1.0) {
            ctx.clearRect(0, 0, vw, vh);
            ctx.globalAlpha = opacity;
            drawEmoji(layer, allEmojis[layer]); // Рисуем новый эмодзи с увеличенной прозрачностью
            opacity += fadeInStep;
            requestAnimationFrame(fadeIn);
          } else {
            // Восстанавливаем полную непрозрачность
            ctx.globalAlpha = 1.0;
            drawEmoji(layer, allEmojis[layer]);
          }
        }
        
        fadeOut();
      }
      
      // Функция для обновления позиций эмодзи с учетом границ экрана
      function updateEmojiPositions() {
        // Плавно изменяем направление движения
        if (Math.random() < 0.02) { // 2% шанс на каждом кадре
          movementDirection.dx += (Math.random() - 0.5) * 0.1;
          movementDirection.dy += (Math.random() - 0.5) * 0.1;
          
          // Нормализуем вектор направления
          const magnitude = Math.sqrt(movementDirection.dx * movementDirection.dx + movementDirection.dy * movementDirection.dy);
          if (magnitude > 0) {
            movementDirection.dx /= magnitude;
            movementDirection.dy /= magnitude;
          }
        }
        
        // Размеры эмодзи для проверки границ (берем самый большой размер)
        const maxEmojiSize = emojiSizes.front * (window.devicePixelRatio >= 2 ? 1.5 : 1);
        const buffer = maxEmojiSize / 2 + 30; // Буфер от краев экрана
        
        // Обновляем позиции для всех слоев с субпиксельной точностью
        Object.keys(emojiPositions).forEach(layer => {
          // Добавляем движение к накопителю
          subPixelAccumulator[layer].x += movementDirection.dx * movementSpeed;
          subPixelAccumulator[layer].y += movementDirection.dy * movementSpeed;
          
          // Извлекаем целую часть для обновления позиции
          const deltaX = Math.floor(subPixelAccumulator[layer].x);
          const deltaY = Math.floor(subPixelAccumulator[layer].y);
          
          if (deltaX !== 0 || deltaY !== 0) {
            emojiPositions[layer].x += deltaX;
            emojiPositions[layer].y += deltaY;
            
            // Обновляем накопитель
            subPixelAccumulator[layer].x -= deltaX;
            subPixelAccumulator[layer].y -= deltaY;
          }
          
          // Проверяем границы и меняем направление при необходимости
          if (emojiPositions[layer].x < buffer || emojiPositions[layer].x > vw - buffer) {
            movementDirection.dx *= -1;
            emojiPositions[layer].x = Math.max(buffer, Math.min(vw - buffer, emojiPositions[layer].x));
            subPixelAccumulator[layer].x = 0; // Сброс накопителя при изменении направления
          }
          
          if (emojiPositions[layer].y < buffer || emojiPositions[layer].y > vh - buffer) {
            movementDirection.dy *= -1;
            emojiPositions[layer].y = Math.max(buffer, Math.min(vh - buffer, emojiPositions[layer].y));
            subPixelAccumulator[layer].y = 0; // Сброс накопителя при изменении направления
          }
        });
        
        // Перерисовываем все эмодзи на новых позициях
        Object.keys(allEmojis).forEach(layer => {
          drawEmoji(layer, allEmojis[layer]);
        });
        
        // Продолжаем анимацию
        if (phase === 'symbol' && lastSelectedMode === 'emoji') {
          requestAnimationFrame(updateEmojiPositions);
        }
      }
      
      // Запускаем анимацию движения
      requestAnimationFrame(updateEmojiPositions);
      
      // Счетчик фокусов на переднем слое
      let frontFocusCount = 0;
      
      function setFocus(target) {
        playFocusSwitch(target);
        const map = { back, mid, front };
        Object.entries(map).forEach(([key, el]) => {
          if (!el) return;
          el.classList.toggle('focus', key === target);
          el.classList.toggle('unfocus', key !== target);
        });
        const center = document.getElementById('center');
        if (center) {
          center.classList.toggle('focusViz', target === 'mid');
          center.classList.toggle('unfocusViz', target !== 'mid');
        }
        
        // Обработка фокуса на переднем слое
        if (target === 'front') {
          frontFocusCount++;
          
          // Если это третий (или более) фокус на переднем слое, меняем эмодзи
          if (frontFocusCount >= 3) {
            // Используем плавный переход при изменении эмодзи
            changeEmojiWithFade('back', getRandomEmoji());
            changeEmojiWithFade('mid', getRandomEmoji());
            changeEmojiWithFade('front', getRandomEmoji());
            
            // Сбрасываем счетчик
            frontFocusCount = 0;
          }
        }
      }
      setFocus('mid');
      
      const focusNames = ['mid', 'back', 'front'];
      const nSwitches = Math.max(1, Math.floor(durationMs / 3000));
      let lastFocus = 'mid';
      const switchTimers = [];
      for (let i = 0; i < nSwitches; i++) {
        let next;
        do {
          next = focusNames[randInt(0, 3)];
        } while (next === lastFocus);
        const at = Math.floor((i + 1) * durationMs / (nSwitches + 1));
        switchTimers.push(setTimeout(() => setFocus(next), at));
        lastFocus = next;
      }
      window._focusTimers.push(...switchTimers);
      
      const center = document.getElementById('center');
      if (center) {
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        center.innerHTML = ``;
      }
      
      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      const doFreeze = () => {
        stopTicking();
        clearFocusTimers();
        removeHintClickHandler();
        if (isHintVisible && currentHintContent) {
          hud.style.transform = 'translateX(-100%)';
          hud.style.opacity = '0';
          isHintVisible = false;
        }
      };
      freezeTimer = setTimeout(doFreeze, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }
    
    function renderTargetMode(durationMs) {
      clearAllTimersAndLoops();
      phaseEndAt = performance.now() + durationMs + 2000 + 2000;
      clearSymbol(); updateHUD(); setTheme(pick(0.5)); startTicking();

      showCycleInfo('target');
      pauseButton.style.display = 'grid';
      // Запускаем таймер обратного отсчета режима
      startModeCountdownTimer(durationMs);

      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      const cx = vw / 2;
      const cy = vh / 2;
      const layersRoot = document.getElementById('layers');
      const midLayer = document.getElementById('layerMid');
      clearLayers();
      
      const center = document.getElementById('center');
      if (center) { center.innerHTML = ''; }
      
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', vw);
      svg.setAttribute('height', vh);
      svg.style.position = 'absolute';
      midLayer.appendChild(svg);
      
      if (layersRoot) { 
        layersRoot.style.opacity = '0';
        requestAnimationFrame(() => { layersRoot.style.opacity = '1'; });
      }
      
      const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#000';
      const allTimers = [];
      window._focusTimers = allTimers;
      
      const circlesData = [];
      let lastRadius = Math.min(vw, vh) * 0.45;
      let lastStrokeWidth = Math.max(4, lastRadius * 0.1);

      const maxSteps = 15;
      for (let i = 0; i < maxSteps; i++) {
        if (i === 0) {
          circlesData.push({ radius: lastRadius, strokeWidth: lastStrokeWidth });
        } else {
          const gap = lastStrokeWidth; 
          const newOuterEdge = (lastRadius - lastStrokeWidth / 2) - gap;
          if (newOuterEdge < 10) break;

          const newStrokeWidth = Math.max(2, newOuterEdge * 0.1);
          const newRadius = newOuterEdge - newStrokeWidth / 2;
          if (newRadius < 5) break;

          circlesData.push({ radius: newRadius, strokeWidth: newStrokeWidth });
          lastRadius = newRadius;
          lastStrokeWidth = newStrokeWidth;
        }
      }
      
      const focusableElements = [];
      
      circlesData.forEach(data => {
        const circleEl = document.createElementNS(svgNS, 'circle');
        circleEl.setAttribute('cx', cx.toFixed(1));
        circleEl.setAttribute('cy', cy.toFixed(1));
        circleEl.setAttribute('r', data.radius.toFixed(1));
        circleEl.setAttribute('stroke', strokeColor);
        circleEl.setAttribute('stroke-width', data.strokeWidth.toFixed(2));
        circleEl.setAttribute('fill', 'none');
        circleEl.classList.add('target-circle');
        svg.appendChild(circleEl);
        focusableElements.push(circleEl);
      });

      const finalDot = document.createElementNS(svgNS, 'circle');
      finalDot.setAttribute('cx', cx.toFixed(1));
      finalDot.setAttribute('cy', cy.toFixed(1));
      finalDot.setAttribute('r', '3');
      finalDot.setAttribute('fill', strokeColor);
      finalDot.classList.add('target-circle');
      svg.appendChild(finalDot);
      focusableElements.push(finalDot);

      // Базовая длительность одного цикла - 2 минуты (120000 мс)
      const baseCycleDuration = 120000; // 2 минуты в миллисекундах
      const pauseDuration = 5000; // 5 секунд паузы
      
      // Если общая длительность больше 2 минут, используем специальный алгоритм
      if (durationMs > baseCycleDuration) {
        // Вычисляем количество полных циклов
        const cycleTime = baseCycleDuration + pauseDuration;
        const fullCycles = Math.floor(durationMs / cycleTime);
        const remainingTime = durationMs % cycleTime;
        
        // Фокусируем на каждом элементе в течение базового цикла
        const FOCUS_SHIFT_INTERVAL = baseCycleDuration / focusableElements.length;
        
        // Запускаем полные циклы
        for (let cycle = 0; cycle < fullCycles; cycle++) {
          const cycleStart = cycle * cycleTime;
          
          focusableElements.forEach((element, index) => {
            const focusTimer = setTimeout(() => {
              if (isPaused) return;
              if (index > 0) {
                focusableElements[index - 1].classList.remove('focus');
              }
              element.classList.add('focus');
              playFocusSwitch('mid'); 
            }, cycleStart + index * FOCUS_SHIFT_INTERVAL);
            allTimers.push(focusTimer);
          });
          
          // Пауза после цикла (кроме последнего цикла)
          if (cycle < fullCycles) {
            const pauseTimer = setTimeout(() => {
              // Убираем фокус с последнего элемента перед паузой
              if (focusableElements.length > 0) {
                focusableElements[focusableElements.length - 1].classList.remove('focus');
              }
            }, cycleStart + baseCycleDuration);
            allTimers.push(pauseTimer);
          }
        }
        
        // Обрабатываем оставшееся время
        if (remainingTime > 0) {
          // Если оставшееся время больше или равно базовой длительности цикла,
          // запускаем еще один полный цикл
          if (remainingTime >= baseCycleDuration) {
            const cycleStart = fullCycles * cycleTime;
            const partialFocusShiftInterval = baseCycleDuration / focusableElements.length;
            
            focusableElements.forEach((element, index) => {
              const focusTimer = setTimeout(() => {
                if (isPaused) return;
                if (index > 0) {
                  focusableElements[index - 1].classList.remove('focus');
                }
                element.classList.add('focus');
                playFocusSwitch('mid'); 
              }, cycleStart + index * partialFocusShiftInterval);
              allTimers.push(focusTimer);
            });
            
            // Добавляем паузу после неполного цикла, если оставшееся время больше базовой длительности
            if (remainingTime > baseCycleDuration) {
              const pauseTimer = setTimeout(() => {
                if (focusableElements.length > 0) {
                  focusableElements[focusableElements.length - 1].classList.remove('focus');
                }
              }, fullCycles * cycleTime + baseCycleDuration);
              allTimers.push(pauseTimer);
            }
          } else {
            // Если оставшееся время меньше базовой длительности,
            // распределяем его между элементами
            const partialFocusShiftInterval = remainingTime / focusableElements.length;
            const cycleStart = fullCycles * cycleTime;
            
            focusableElements.forEach((element, index) => {
              const focusTimer = setTimeout(() => {
                if (isPaused) return;
                if (index > 0) {
                  focusableElements[index - 1].classList.remove('focus');
                }
                element.classList.add('focus');
                playFocusSwitch('mid'); 
              }, cycleStart + index * partialFocusShiftInterval);
              allTimers.push(focusTimer);
            });
          }
        }
        
        // Убедимся, что последний элемент остается в фокусе до конца
        const finalFocusTimer = setTimeout(() => {
          if (isPaused) return;
          // Фокус остается на последнем элементе (центральной точке)
          // Все остальные элементы теряют фокус
          for (let i = 0; i < focusableElements.length - 1; i++) {
            focusableElements[i].classList.remove('focus');
          }
          // Центральная точка остается в фокусе
          finalDot.classList.add('focus');
        }, durationMs - 2000); // За 2 секунды до окончания режима
        allTimers.push(finalFocusTimer);
      } else {
        // Если длительность 2 минуты или меньше, используем стандартный алгоритм
        const FOCUS_SHIFT_INTERVAL = durationMs / focusableElements.length;
        
        focusableElements.forEach((element, index) => {
          const focusTimer = setTimeout(() => {
            if (isPaused) return;
            if (index > 0) {
              focusableElements[index - 1].classList.remove('focus');
            }
            element.classList.add('focus');
            playFocusSwitch('mid'); 
          }, index * FOCUS_SHIFT_INTERVAL);
          allTimers.push(focusTimer);
        });
        
        // Убедимся, что последний элемент остается в фокусе до конца
        const finalFocusTimer = setTimeout(() => {
          if (isPaused) return;
          // Фокус остается на последнем элементе (центральной точке)
          // Все остальные элементы теряют фокус
          for (let i = 0; i < focusableElements.length - 1; i++) {
            focusableElements[i].classList.remove('focus');
          }
          // Центральная точка остается в фокусе
          finalDot.classList.add('focus');
        }, durationMs - 2000); // За 2 секунды до окончания режима
        allTimers.push(finalFocusTimer);
      }

      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      const doFreeze = () => {
        stopTicking();
        clearFocusTimers();
        removeHintClickHandler();
        if (isHintVisible && currentHintContent) {
          hud.style.transform = 'translateX(-100%)';
          hud.style.opacity = '0';
          isHintVisible = false;
        }
      };
      freezeTimer = setTimeout(doFreeze, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }


    function renderSymbolFor(durationMs) {
      clearAllTimersAndLoops();
      phaseEndAt = performance.now() + durationMs + 2000 + 2000;
      clearSymbol(); updateHUD();

      showCycleInfo('symbol');
      pauseButton.style.display = 'grid';
      // Запускаем таймер обратного отсчета режима
      startModeCountdownTimer(durationMs);

      const flipTheme = pick(0.10);
      setTheme(flipTheme);

      const sizeRatio = rand(0.30, 0.90);
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      const minDim = Math.min(vw, vh);
      const maxScale = 1.25;
      const sizePx = Math.floor(minDim * sizeRatio / maxScale);
      const rotate = 0;
      let left = (vw - sizePx) / 2;
      let top = (vh - sizePx) / 2;

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }

      const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#000';
      
      // Variables to store symbol wrappers for redrawing
      let symbolWrappers = [];
      
      function mountTo(layerEl, scale) {
        const wrap = document.createElement('div');
        wrap.className = 'symbolWrapper';
        wrap.style.width = sizePx + 'px';
        wrap.style.height = sizePx + 'px';
        wrap.style.transform = `translate(${left}px,${top}px) rotate(${rotate}deg) scale(${scale})`;
        const svg = createGlyphSVG(sizePx, strokeColor);
        wrap.appendChild(svg);
        layerEl.appendChild(wrap);
        // Animate for 1 minute (60000ms)
        animateGlyph(svg, 60000);
        return wrap;
      }

      // Function to create and animate symbols
      function createAndAnimateSymbols() {
        // Clear existing symbols
        symbolWrappers.forEach(wrapper => {
          if (wrapper && wrapper.parentNode) {
            wrapper.parentNode.removeChild(wrapper);
          }
        });
        symbolWrappers = [];
        
        // Create new symbols
        symbolWrappers.push(mountTo(back, 0.8));
        symbolWrappers.push(mountTo(mid, 1.0));
        symbolWrappers.push(mountTo(front, 1.25));
      }
      
      // Initial symbol creation
      createAndAnimateSymbols();
      
      // Redraw symbols every minute until mode duration ends
      const redrawInterval = setInterval(() => {
        if (performance.now() < phaseEndAt - 2000 - 2000) {
          createAndAnimateSymbols();
        }
      }, 60000);

      if (layersRoot) {
        requestAnimationFrame(() => { layersRoot.style.opacity = '1'; });
      }

      function setFocus(target) {
        playFocusSwitch(target);
        const map = { back, mid, front };
        Object.entries(map).forEach(([key, el]) => {
          if (!el) return;
          el.classList.toggle('focus', key === target);
          el.classList.toggle('unfocus', key !== target);
        });
        const center = document.getElementById('center');
        if (center) {
          center.classList.toggle('focusViz', target === 'mid');
          center.classList.toggle('unfocusViz', target !== 'mid');
        }
      }
      
      const initialTarget = 'mid';
      const map = { back, mid, front };
      Object.entries(map).forEach(([key, el]) => {
        if (!el) return;
        el.classList.toggle('focus', key === initialTarget);
        el.classList.toggle('unfocus', key !== initialTarget);
      });
      const centerEl = document.getElementById('center');
      if (centerEl) {
        centerEl.classList.toggle('focusViz', initialTarget === 'mid');
        centerEl.classList.toggle('unfocusViz', initialTarget !== 'mid');
      }

      // Change focus every 10 seconds
      const focusNames = ['mid', 'back', 'front'];
      const focusInterval = 10000; // 10 seconds
      let lastFocus = 'mid';
      const switchTimers = [];
      
      // Set up recurring focus changes
      const focusChangeTimer = setInterval(() => {
        let next;
        do {
          next = focusNames[randInt(0, 3)];
        } while (next === lastFocus);
        setFocus(next);
        lastFocus = next;
      }, focusInterval);
      
      // Store timer for cleanup
      window._focusTimers.push(focusChangeTimer);
      window._focusTimers.push(redrawInterval);

      startTicking();

      const center = document.getElementById('center');
      if (center) {
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        center.innerHTML = ``;
      }
      
      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      const doFreeze = () => {
        stopTicking();
        clearFocusTimers();
        removeHintClickHandler();
        if (isHintVisible && currentHintContent) {
          hud.style.transform = 'translateX(-100%)';
          hud.style.opacity = '0';
          isHintVisible = false;
        }
      };
      freezeTimer = setTimeout(doFreeze, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }

    function showSymbol() {
      phase = 'symbol';
      // Используем настройку длительности режимов (в минутах)
      const showMs = modeDuration * 60 * 1000;
      currentDrawMs = showMs;
      
      const intro = document.getElementById('intro');
      if (intro && !intro.classList.contains('hide')) {
        intro.classList.add('hide');
      }
      hasStarted = true;
      
      clearFlickerTimer(); 
      if (Math.random() < 0.20) {
        const flickerAt = rand(1000, showMs - 2000); 
        flickerTimer = setTimeout(triggerGreenFlicker, flickerAt);
      }

      const availableModes = [];
      if (document.getElementById('modeSymbol').checked) availableModes.push('symbol');
      if (document.getElementById('modeTarget').checked) availableModes.push('target');
      if (document.getElementById('modeWords').checked) availableModes.push('words');
      if (document.getElementById('modeEmoji').checked) availableModes.push('emoji');
      if (document.getElementById('modeDance').checked) availableModes.push('dance');
      if (document.getElementById('modeStars').checked) availableModes.push('stars');
      
      let selectedMode;
      
      // Используем настройку последовательности режимов
      if (modeSequence === 'sequential' && availableModes.length > 1) {
        // Последовательный порядок режимов
        if (lastSelectedMode) {
          const currentIndex = availableModes.indexOf(lastSelectedMode);
          // Выбираем следующий режим в списке, или первый если текущий последний
          selectedMode = availableModes[(currentIndex + 1) % availableModes.length];
        } else {
          // Если нет предыдущего режима, выбираем первый
          selectedMode = availableModes[0];
        }
      } else {
        // Случайный порядок режимов (по умолчанию)
        let selectionPool = [...availableModes];
        if (lastSelectedMode && availableModes.length > 1) {
          selectionPool = availableModes.filter(mode => mode !== lastSelectedMode);
        }
        selectedMode = selectionPool[Math.floor(Math.random() * selectionPool.length)] || 'symbol';
      }
      
      lastSelectedMode = selectedMode;
      
      // Для режима "Мишень" используем специальный алгоритм
      const duration = selectedMode === 'target' ? showMs : showMs;

      switch (selectedMode) {
        case 'target': renderTargetMode(duration); break;
        case 'words': renderWordsMode(duration); break;
        case 'emoji': renderEmojiMode(duration); break;
        case 'dance': renderDanceMode(duration); break;
        case 'stars': renderStarsMode(duration); break;
        default: renderSymbolFor(duration);
      }
    }

    function startPause() {
      // Если включен режим без отдыха, переходим к следующему режиму сразу
      if (noBreakMode) {
        showSymbol();
        return;
      }
      
      phase = 'pause';
      pauseButton.style.display = 'none';
      updateHUD();
      stopTicking();
      stopContinuousNoise(); 
      setTheme(true);
      clearSymbol();
      clearLayers();
      clearAllTimersAndLoops();
      
      removeHintClickHandler();
      
      if (isHintVisible && currentHintContent) {
        hud.style.transform = 'translateX(-100%)';
        hud.style.opacity = '0';
        isHintVisible = false;
      }

      const center = document.getElementById('center');
      if (center) {
        const restText = currentLanguage === 'ru' ? 'Отдых...' : 'Rest...';
        const continueText = currentLanguage === 'ru' ? 'Нажмите для продолжения' : 'Click to continue';
        const autoContinueText = currentLanguage === 'ru' ? 'Автоматическое продолжение' : 'Auto continue';
        const backToStartText = currentLanguage === 'ru' ? 'В меню' : 'To Menu';
        center.innerHTML = `
          <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            <div class="title large pulse-large">${restText}</div>
          </div>
          <small id="continueHint" style="position: absolute; bottom: 30%; left: 0; right: 0; font-size: 16px; opacity: 0.7; display: ${autoContinueEnabled ? 'none' : 'block'};">${continueText}</small>
          <div style="position: absolute; bottom: 22%; left: 50%; transform: translateX(-50%); pointer-events: auto;">
            <label style="display: flex; align-items: center; justify-content: center; font-size: 14px; opacity: 0.8; cursor: pointer; user-select: none;">
              <input type="checkbox" id="autoContinueCheckbox" ${autoContinueEnabled ? 'checked' : ''}>
              <span>${autoContinueText}</span>
            </label>
            <div id="countdownContainer" style="text-align: center; margin-top: 12px; display: ${autoContinueEnabled ? 'block' : 'none'};">
              <div id="countdownDisplay">${countdownSeconds}</div>
            </div>
          </div>
          <button id="backToStartBtn" style="
            position: absolute;
            bottom: 8%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            pointer-events: auto;
          " onmouseover="this.style.transform='translateX(-50%) translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)'" onmouseout="this.style.transform='translateX(-50%) translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.3)'">${backToStartText}</button>
        `;
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        
        // Ждем клик на кнопке перезапуска
        const backToStartBtn = document.getElementById('backToStartBtn');
        if (backToStartBtn) {
          backToStartBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            window.location.reload();
          });
        }
        
        // Ждём клика по чекбоксу автоматического перезапуска
        const autoContinueCheckbox = document.getElementById('autoContinueCheckbox');
        if (autoContinueCheckbox) {
          autoContinueCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            autoContinueEnabled = autoContinueCheckbox.checked;
            savePreferences();
            
            const continueHint = document.getElementById('continueHint');
            if (continueHint) {
              continueHint.style.display = autoContinueEnabled ? 'none' : 'block';
            }
            
            if (autoContinueEnabled) {
              showCountdownDisplay();
              startAutoContinueCountdown();
            } else {
              stopAutoContinueCountdown();
            }
          });
        }
        
        // Запуск отсчёта
        if (autoContinueEnabled) {
          startAutoContinueCountdown();
        }
      }

      app.addEventListener('click', proceedToNextCycle, { once: true });
    }
    
    function proceedToNextCycle(event) {
        if(event) {
          event.stopPropagation();
        }
        if(phase === 'pause') {
            // Остановка таймера
            stopAutoContinueCountdown();
            showSymbol();
        }
    }

    window.addEventListener('resize', () => {
      clearTimeout(resizeRaf);
      resizeRaf = setTimeout(() => {
        if (phase === 'symbol' && !isPaused) {
          const remaining = Math.max(300, Math.floor(phaseEndAt - performance.now()));
          
          switch (lastSelectedMode) {
              case 'symbol': renderSymbolFor(remaining); break;
              case 'target': renderTargetMode(remaining); break;
              case 'words': renderWordsMode(remaining); break;
              case 'emoji': renderEmojiMode(remaining); break;
              case 'dance': renderDanceMode(remaining); break;
              case 'stars': renderStarsMode(remaining); break;
              default: showSymbol();
          }
        }
      }, 120);
    });
    let resizeRaf = null;

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {});
        }
      } catch (e) {}
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && !isPaused) {
        if (!wakeLock) requestWakeLock();
        if (phase === 'symbol') {
          const remaining = Math.max(300, Math.floor(phaseEndAt - performance.now()));
          
          switch (lastSelectedMode) {
              case 'symbol': renderSymbolFor(remaining); break;
              case 'target': renderTargetMode(remaining); break;
              case 'words': renderWordsMode(remaining); break;
              case 'emoji': renderEmojiMode(remaining); break;
              case 'dance': renderDanceMode(remaining); break;
              case 'stars': renderStarsMode(remaining); break;
              default: showSymbol();
          }
        }
      } else if (document.visibilityState === 'hidden' && phase === 'symbol' && !isPaused) {
          enterPause();
      }
    });

    function initIntroScreen() {
      const startButton = document.getElementById('startButton');
      const soundCheckbox = document.getElementById('soundCheckbox');
      const hintsCheckbox = document.getElementById('hintsCheckbox');
      const languageRadios = document.querySelectorAll('input[name="language"]');
      const checkboxes = [
        document.getElementById('modeSymbol'),
        document.getElementById('modeTarget'),
        document.getElementById('modeWords'),
        document.getElementById('modeEmoji'),
        document.getElementById('modeDance'),
        document.getElementById('modeStars')
      ];

      // Загружаем настройки из localStorage
      loadPreferences();
      
      // Показ версии
      updateVersionDisplay();

      // Переключение языка
      languageRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          if (e.target.checked) {
            updateLanguage(e.target.value);
          }
        });
      });

      function validateCheckboxes() {
        const checkedCheckboxes = checkboxes.filter(cb => cb.checked);
        if (checkedCheckboxes.length === 1) {
          checkedCheckboxes[0].disabled = true;
        } else {
          checkboxes.forEach(cb => cb.disabled = false);
        }
        savePreferences();
      }

      checkboxes.forEach(cb => {
        cb.addEventListener('change', validateCheckboxes);
      });
      
      soundCheckbox.addEventListener('change', () => {
        soundEnabled = soundCheckbox.checked;
        if(soundEnabled && !audioCtx) {
            initAudio();
        }
        updateHUD();
        savePreferences();
      });
      
      hintsCheckbox.addEventListener('change', () => {
        hintsEnabled = hintsCheckbox.checked;
        savePreferences();
      });
      
      startButton.addEventListener('click', (e) => {
        e.stopPropagation();
        // Проверяем, включены ли подсказки
        if (hintsEnabled) {
          // Показываем popup с информацией
          showTrainingInfoPopup();
        } else {
          // Если подсказки выключены, запускаем тренировку напрямую
          showSymbol();
          if (soundEnabled && !audioCtx) initAudio();
        }
      });

      // Функция для показа popup с информацией о тренировке
      function showTrainingInfoPopup() {
        const popup = document.getElementById('trainingInfoPopup');
        if (popup) {
          popup.style.display = 'grid';
          
          // Обновляем язык в popup
          updateLanguage(currentLanguage);
          
          // Добавляем обработчик для кнопки запуска
          const launchBtn = document.getElementById('launchTrainerBtn');
          if (launchBtn) {
            // Удаляем предыдущие обработчики, чтобы избежать дублирования
            const newBtn = launchBtn.cloneNode(true);
            launchBtn.parentNode.replaceChild(newBtn, launchBtn);
            
            newBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              popup.style.display = 'none';
              showSymbol();
              if (soundEnabled && !audioCtx) initAudio();
            });
          }
        }
      }

      validateCheckboxes();
    }

    updateHUD();
    setTheme(true);
    initIntroScreen();
    
  })();
  </script>
</body>
</html>
