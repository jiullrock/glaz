<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>GLAZ ‚Äî —Ç—Ä–µ–Ω–∞–∂—ë—Ä –¥–ª—è –≥–ª–∞–∑</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #000000;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, sans-serif;
      overflow: hidden;
      touch-action: manipulation;
      user-select: none;
    }
    #app {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      transition: background-color 250ms ease;
    }
    .symbolWrapper {
      position: absolute;
      will-change: transform;
      display: grid;
      place-items: center;
      pointer-events: none; /* –∫–ª–∏–∫–∏ –ø—Ä–æ—Ö–æ–¥—è—Ç —Å–∫–≤–æ–∑—å */
    }
    .symbolWrapper.hidden { display: none; }
    .symbolWrapper svg { shape-rendering: geometricPrecision; }
    .hud {
      position: fixed;
      left: 10px; bottom: 10px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.06);
      color: #111;
      backdrop-filter: blur(6px);
      font-size: 14px;
      line-height: 1.25;
      max-width: min(92vw, 520px);
      transition: opacity .25s ease;
    }
    .dark .hud { background: rgba(255,255,255,.08); color: #f5f5f5; }
    .hud small { opacity: .7; }
    .hud .dot { display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; vertical-align:middle; }
    .phase-symbol .dot { background: #2a7; }
    .phase-pause .dot { background: #999; }
    .muteBadge { position: fixed; right: 10px; bottom: 10px; font-size: 14px; opacity: .8; }
    @media (max-width: 600px) {
      .hud { font-size: 12px; padding: 6px 10px; }
    }
    .intro {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 1000;
      pointer-events: none;
      color: #ffffff;
      background: #000000;
      font-weight: 700;
      font-size: clamp(28px, 8vw, 96px);
      line-height: 1.1;
      letter-spacing: 0.02em;
      text-align: center;
      opacity: 0.92;
      transition: opacity .5s ease;
    }
    .intro.hide { opacity: 0; }
    .intro small {
      display: block;
      margin-top: 12px;
      font-weight: 500;
      font-size: clamp(12px, 2.5vw, 16px);
      opacity: 0.7;
    }
    .intro a { color: #dddddd; text-decoration: none; pointer-events: auto; opacity: 0.8; }
    .intro a:hover { text-decoration: underline; opacity: 1; }
    @keyframes introPulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
    .introText { animation: introPulse 3.5s ease-in-out infinite; }
    .centerOverlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      z-index: 1200;
      pointer-events: none;
      color: var(--fg);
    }
    .centerOverlay .title.small { font-size: clamp(14px, 2.6vw, 20px); font-weight: 600; opacity: 0.85; }
    .centerOverlay .title.large { font-size: clamp(28px, 6vw, 72px); font-weight: 700; opacity: 0.28; letter-spacing: 0.02em; }
    .centerOverlay .counter { margin-top: 8px; font-size: clamp(48px, 10vw, 160px); font-weight: 800; line-height: 1.0; }
    @keyframes pulseSmall {
      0% { opacity: 0.65; }
      50% { opacity: 0.95; }
      100% { opacity: 0.65; }
    }
    @keyframes pulseLarge {
      0% { opacity: 0.22; }
      50% { opacity: 0.36; }
      100% { opacity: 0.22; }
    }
    .centerOverlay .pulse-small { animation: pulseSmall 4.5s ease-in-out infinite; }
    .centerOverlay .pulse-large { animation: pulseLarge 5.5s ease-in-out infinite; }
    .shutters {
      position: fixed;
      inset: 0;
      z-index: 1100;
      pointer-events: none;
    }
    .shutters .top, .shutters .bottom {
      position: absolute;
      left: 0; right: 0;
      background: #000;
      height: 0%;
      transition: height 2000ms ease-in-out;
    }
    .shutters .top { top: 0; }
    .shutters .bottom { bottom: 0; }
    .shutters.active .top { height: 50%; }
    .shutters.active .bottom { height: 50%; }
    /* Layers for depth focusing */
    .layers {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .layer {
      position: absolute;
      width: 100%;
      height: 100%;
      transition: filter 2500ms ease-in-out, opacity 2500ms ease-in-out, transform 2500ms ease-in-out;
      will-change: filter, transform, opacity;
    }
    .layer .symbolWrapper { position: relative; left: 0; top: 0; }
    .layer.focus { filter: blur(0px); opacity: 1; }
    .layer.unfocus { filter: blur(7px); opacity: 0.85; }
    #layerBack { z-index: 10; }
    #layerMid { z-index: 20; }
    #layerFront { z-index: 30; }
    /* Blur helpers for non-layer overlays */
    .focusViz { filter: blur(0px); opacity: 1; transition: filter 2500ms ease-in-out, opacity 2500ms ease-in-out; }
    .unfocusViz { filter: blur(7px); opacity: 0.85; transition: filter 2500ms ease-in-out, opacity 2500ms ease-in-out; }
    .hiddenSoft { opacity: 0 !important; animation: none !important; transition: opacity 3000ms ease-in-out !important; }
  </style>
</head>
<body>
  <div id="app" aria-label="GLAZ —Ç—Ä–µ–Ω–∞–∂—ë—Ä" role="application"></div>
  <div class="hud" id="hud"></div>
  <div class="muteBadge" id="mute">üîä –ó–≤—É–∫ –≤–∫–ª—é—á—ë–Ω</div>
  <div class="intro" id="intro"><span class="introText">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...</span><br><small>–ö–ª–∏–∫ –≤–∫–ª—é—á–∞–µ—Ç/–≤—ã–∫–ª—é—á–∞–µ—Ç –∑–≤—É–∫</small><small><a href="https://t.me/psylachi" target="_blank" rel="noopener">https://t.me/psylachi</a></small></div>
  <div class="centerOverlay" id="center"></div>
  <div class="layers" id="layers">
    <div class="layer" id="layerBack"></div>
    <div class="layer" id="layerMid"></div>
    <div class="layer" id="layerFront"></div>
  </div>
  <div class="shutters" id="shutters"><div class="top"></div><div class="bottom"></div></div>

  <script>
  (function() {
    const app = document.getElementById('app');
    const hud = document.getElementById('hud');
    const mute = document.getElementById('mute');

    let audioCtx = null;
    let masterGain = null;
    let tickingInterval = null;
    let phaseTimer = null;
    let freezeTimer = null;
    let shutterTimer = null;
    let counterTimer = null;
    let phaseEndAt = 0;
    let hasStarted = false;
    let currentDrawMs = 0;
    let wakeLock = null;
    let soundEnabled = false; // –∑–≤—É–∫ –≤–∫–ª—é—á–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º –∫–ª–∏–∫–æ–º

    let phase = 'pause'; // 'symbol' | 'pause'
    let symbolWrapper = null;

    const SHOW_MS = 7000; // —Å–∏–º–≤–æ–ª –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è 7 —Å–µ–∫

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function randInt(min, max) { return Math.floor(rand(min, max)); }
    function pick(pTrue=0.5) { return Math.random() < pTrue; }

    function initAudio() {
      if (audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.9;
        masterGain.connect(audioCtx.destination);
      } catch (e) {
        console.warn('Audio init failed', e);
      }
    }

    function setTheme(isDark) {
      document.documentElement.classList.toggle('dark', isDark);
      document.documentElement.style.setProperty('--bg', isDark ? '#000000' : '#ffffff');
      document.documentElement.style.setProperty('--fg', isDark ? '#ffffff' : '#000000');
      app.style.backgroundColor = isDark ? '#000' : '#fff';
      app.style.color = isDark ? '#fff' : '#000';
    }

    function updateHUD() {
      const isDark = document.documentElement.classList.contains('dark');
      const sound = soundEnabled ? 'üîä' : 'üîá';
      mute.textContent = soundEnabled ? '' : '';
      hud.className = 'hud phase-' + phase;
      hud.innerHTML = ``;
      hud.style.opacity = phase === 'symbol' ? 0.9 : 0.6;
    }

    function playTick() {
      if (!audioCtx || !soundEnabled || phase !== 'symbol') return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      // –ø—Ä–∏—è—Ç–Ω—ã–π –∫–æ—Ä–æ—Ç–∫–∏–π ¬´—Ç–∏–∫¬ª
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(980 + Math.random()*40, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.25, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.10);
      osc.connect(gain).connect(masterGain);
      osc.start(now);
      osc.stop(now + 0.12);
    }

    function startTicking() {
      stopTicking();
      playTick();
      tickingInterval = setInterval(playTick, 1000);
    }

    function stopTicking() {
      if (tickingInterval) { clearInterval(tickingInterval); tickingInterval = null; }
    }

    function clearSymbol() {
      if (symbolWrapper && symbolWrapper.parentNode) {
        symbolWrapper.parentNode.removeChild(symbolWrapper);
      }
      symbolWrapper = null;
    }

    function clearPhaseTimer() {
      if (phaseTimer) { clearTimeout(phaseTimer); phaseTimer = null; }
    }
    function clearFreezeTimer() { if (freezeTimer) { clearTimeout(freezeTimer); freezeTimer = null; } }
    function clearShutterTimer() { if (shutterTimer) { clearTimeout(shutterTimer); shutterTimer = null; } }
    function clearCounterTimer() { if (counterTimer) { clearInterval(counterTimer); counterTimer = null; } }
    function clearFocusTimers() {
      if (window._focusTimers && Array.isArray(window._focusTimers)) {
        window._focusTimers.forEach(t => clearTimeout(t));
      }
      window._focusTimers = [];
    }
    function clearCounterVisTimers() {
      if (window._counterVisTimers && Array.isArray(window._counterVisTimers)) {
        window._counterVisTimers.forEach(t => clearTimeout(t));
      }
      window._counterVisTimers = [];
    }
    function clearLayers() {
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => {
        if (!el) return;
        el.innerHTML = '';
        el.classList.remove('focus', 'unfocus');
      });
    }

    function applyDrawAnimation(el, durationMs, delayMs) {
      try {
        const length = el.getTotalLength();
        const lenStr = length.toFixed(1);
        el.style.strokeDasharray = `${lenStr} ${lenStr}`;
        el.style.strokeDashoffset = lenStr;
        const durMs = Math.max(300, Math.floor(durationMs || 1000));
        const delMs = Math.max(0, Math.floor(delayMs || 0));
        // —Å—Ç–∞—Ä—Ç –±–µ–∑ transition, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞
        el.style.transition = 'none';
        el.style.willChange = 'stroke-dashoffset';
        void el.getBoundingClientRect();
        requestAnimationFrame(() => {
          el.style.transitionProperty = 'stroke-dashoffset';
          el.style.transitionTimingFunction = 'linear';
          el.style.transitionDuration = `${durMs}ms`;
          el.style.transitionDelay = `${delMs}ms`;
          requestAnimationFrame(() => {
            if (!el.isConnected) return;
            el.style.strokeDashoffset = '0';
          });
        });
      } catch (e) {
        // —ç–ª–µ–º–µ–Ω—Ç –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å getTotalLength
      }
    }

    function animateGlyph(svgRoot, durationMs) {
      if (!svgRoot) return;
      const elements = Array.from(svgRoot.querySelectorAll('path, line, polyline, polygon, circle, rect'));
      const total = elements.length || 1;
      elements.forEach((el, i) => {
        const delayMs = Math.floor((i / total) * durationMs);
        const durMs = Math.max(200, durationMs - delayMs);
        applyDrawAnimation(el, durMs, delayMs);
      });
    }

    function createGlyphSVG(sizePx, strokeColor) {
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', sizePx);
      svg.setAttribute('height', sizePx);
      svg.setAttribute('viewBox', '0 0 1000 1000');
      svg.setAttribute('aria-label', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª');

      // –§–æ–Ω –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π, —Ä–∏—Å—É–µ–º ¬´–Ω–µ–∑–Ω–∞–∫–æ–º—ã–π¬ª –∑–Ω–∞–∫: —Å–º–µ—Å—å –ª–∏–Ω–∏–π, –¥—É–≥ –∏ –ø—è—Ç–µ–Ω
      const g = document.createElementNS(svgNS, 'g');
      g.setAttribute('fill', 'none');
      g.setAttribute('stroke', strokeColor);
      g.setAttribute('stroke-linecap', 'round');
      g.setAttribute('stroke-linejoin', 'round');

      // –°–ª—É—á–∞–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —à—Ç—Ä–∏—Ö–æ–≤
      const base = rand(10, 26); // –±–∞–∑–æ–≤–∞—è —Ç–æ–ª—â–∏–Ω–∞
      const strokes = randInt(6, 13);

      for (let i = 0; i < strokes; i++) {
        const path = document.createElementNS(svgNS, 'path');
        const cx = rand(180, 820); // —Ü–µ–Ω—Ç—Ä —Å–µ–≥–º–µ–Ω—Ç–∞
        const cy = rand(180, 820);
        const r1 = rand(60, 360);
        const r2 = rand(60, 360);
        const a1 = rand(0, Math.PI*2);
        const a2 = a1 + rand(-1.6, 1.6);
        const x1 = cx + Math.cos(a1) * r1;
        const y1 = cy + Math.sin(a1) * r1;
        const x2 = cx + Math.cos(a2) * r2;
        const y2 = cy + Math.sin(a2) * r2;
        const qx = cx + rand(-220, 220);
        const qy = cy + rand(-220, 220);
        const w = base * rand(0.7, 2.2);
        path.setAttribute('d', `M ${x1.toFixed(1)} ${y1.toFixed(1)} Q ${qx.toFixed(1)} ${qy.toFixed(1)} ${x2.toFixed(1)} ${y2.toFixed(1)}`);
        path.setAttribute('stroke-width', w.toFixed(2));
        g.appendChild(path);
      }

      // –ù–µ—Å–∫–æ–ª—å–∫–æ ¬´–ø—è—Ç–µ–Ω¬ª –¥–ª—è –∑–∞–≥–∞–¥–æ—á–Ω–æ—Å—Ç–∏
      const blobs = randInt(1, 4);
      for (let i = 0; i < blobs; i++) {
        const path = document.createElementNS(svgNS, 'path');
        const cx = rand(200, 800);
        const cy = rand(200, 800);
        const r = rand(40, 180);
        const k = 0.5522847498; // –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ –¥–ª—è –∫—Ä–∏–≤—ã—Ö –ë–µ–∑—å–µ –∫—Ä—É–≥–∞
        const ox = r * k * rand(0.7, 1.3);
        const oy = r * k * rand(0.7, 1.3);
        const strokeW = base * rand(0.9, 1.6);
        const d = [
          `M ${cx - r} ${cy}`,
          `C ${cx - r} ${cy - oy}, ${cx - ox} ${cy - r}, ${cx} ${cy - r}`,
          `C ${cx + ox} ${cy - r}, ${cx + r} ${cy - oy}, ${cx + r} ${cy}`,
          `C ${cx + r} ${cy + oy}, ${cx + ox} ${cy + r}, ${cx} ${cy + r}`,
          `C ${cx - ox} ${cy + r}, ${cx - r} ${cy + oy}, ${cx - r} ${cy} Z`
        ].join(' ');
        path.setAttribute('d', d);
        path.setAttribute('stroke-width', strokeW.toFixed(2));
        path.setAttribute('fill', 'none');
        g.appendChild(path);
      }

      // —Ä–µ–¥–∫–∞—è ¬´—à—Ç—Ä–∏—Ö–æ–≤–∫–∞¬ª
      if (pick(0.35)) {
        const lines = randInt(6, 14);
        for (let i = 0; i < lines; i++) {
          const line = document.createElementNS(svgNS, 'line');
          const ang = rand(0, Math.PI*2);
          const len = rand(100, 600);
          const cx = rand(150, 850);
          const cy = rand(150, 850);
          const x1 = cx - Math.cos(ang) * len/2;
          const y1 = cy - Math.sin(ang) * len/2;
          const x2 = cx + Math.cos(ang) * len/2;
          const y2 = cy + Math.sin(ang) * len/2;
          line.setAttribute('x1', x1.toFixed(1));
          line.setAttribute('y1', y1.toFixed(1));
          line.setAttribute('x2', x2.toFixed(1));
          line.setAttribute('y2', y2.toFixed(1));
          line.setAttribute('stroke-width', (base*rand(0.4,1.2)).toFixed(2));
          line.setAttribute('stroke', strokeColor);
          line.setAttribute('stroke-linecap', 'round');
          g.appendChild(line);
        }
      }

      svg.appendChild(g);
      return svg;
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª–æ–≤–∞ –∏–∑ –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã—Ö –±—É–∫–≤ —Ç—Ä—ë—Ö –∞–ª—Ñ–∞–≤–∏—Ç–æ–≤
    function mixedLangWord() {
      const ru = '–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—ã—ä—ç—é—è';
      const en = 'abcdefghijklmnopqrstuvwxyz';
      const cn = 'ÁöÑ‰∏ÄÊòØÂú®‰∏ç‰∫ÜÊúâÂíå‰∫∫Ëøô‰∏≠Â§ß‰∏∫‰∏ä‰∏™ÂõΩÊàë‰ª•Ë¶Å‰ªñÊó∂Êù•Áî®‰ª¨ÁîüÂà∞‰ΩúÂú∞‰∫éÂá∫Â∞±ÂàÜÂØπÊàê‰ºöÂèØ‰∏ªÂèëÂπ¥Âä®ÂêåÂ∑•‰πüËÉΩ‰∏ãËøáÂ≠êËØ¥‰∫ßÁßçÈù¢ËÄåÊñπÂêéÂ§öÂÆöË°åÂ≠¶Ê≥ïÊâÄÊ∞ëÂæóÁªèÂçÅ‰∏â‰πãËøõÁùÄÁ≠âÈÉ®Â∫¶ÂÆ∂ÁîµÂäõÈáåÂ¶ÇÊ∞¥ÂåñÈ´òËá™‰∫åÁêÜËµ∑Â∞èÁâ©Áé∞ÂÆûÂä†ÈáèÈÉΩ‰∏§‰ΩìÂà∂Êú∫ÂΩì‰ΩøÁÇπ‰ªé‰∏öÊú¨ÂéªÊääÊÄßÂ•ΩÂ∫îÂºÄÂÆÉÂêàËøòÂõ†Áî±ÂÖ∂‰∫õÁÑ∂ÂâçÂ§ñÂ§©ÊîøÂõõÊó•ÈÇ£Á§æ‰πâ‰∫ãÂπ≥ÂΩ¢Áõ∏ÂÖ®Ë°®Èó¥Ê†∑‰∏éÂÖ≥ÂêÑÈáçÊñ∞Á∫øÂÜÖÊï∞Ê≠£ÂøÉÂèç‰Ω†ÊòéÁúãÂéüÂèà‰πàÂà©ÊØîÊàñ‰ΩÜË¥®Ê∞îÁ¨¨ÂêëÈÅìÂëΩÊ≠§ÂèòÊù°Âè™Ê≤°ÁªìËß£ÈóÆÊÑèÂª∫ÊúàÂÖ¨Êó†Á≥ªÂÜõÂæàÊÉÖËÄÖÊúÄÁ´ã‰ª£ÊÉ≥Â∑≤ÈÄöÂπ∂ÊèêÁõ¥È¢òÂÖöÁ®ãÂ±ï‰∫îÊûúÊñôË±°ÂëòÈù©‰ΩçÂÖ•Â∏∏ÊñáÊÄªÊ¨°ÂìÅÂºèÊ¥ªËÆæÂèäÁÆ°Áâπ‰ª∂ÈïøÊ±ÇËÄÅÂ§¥Âü∫ËµÑËæπÊµÅË∑ØÁ∫ßÂ∞ëÂõæÂ±±ÁªüÊé•Áü•ËæÉÂ∞ÜÁªÑËßÅËÆ°Âà´Â•πÊâãËßíÊúüÊ†πËÆ∫ËøêÂÜúÊåáÂá†‰πùÂå∫Âº∫ÊîæÂÜ≥Ë•øË¢´Âπ≤ÂÅöÂøÖÊàòÂÖàÂõûÂàô‰ªªÂèñÊçÆÂ§ÑÈòüÂçóÁªôËâ≤ÂÖâÈó®Âç≥‰øùÊ≤ªÂåóÈÄ†ÁôæËßÑÁÉ≠È¢Ü‰∏ÉÊµ∑Âè£‰∏úÂØºÂô®ÂéãÂøó‰∏ñÈáëÂ¢û‰∫âÊµéÈò∂Ê≤πÊÄùÊúØÊûÅ‰∫§ÂèóËÅî‰ªÄËÆ§ÂÖ≠ÂÖ±ÊùÉÊî∂ËØÅÊîπÊ∏ÖÂ∑±ÁæéÂÜçÈááËΩ¨ÂçïÈ£éÂàáÊâìÁôΩÊïôÈÄüËä±Â∏¶ÂÆâÂú∫Ë∫´ËΩ¶‰æãÁúüÂä°ÂÖ∑‰∏áÊØèÁõÆËá≥ËææËµ∞ÁßØÁ§∫ËÆÆÂ£∞Êä•ÊñóÂÆåÁ±ªÂÖ´Á¶ªÂçéÂêçÁ°ÆÊâçÁßëÂº†‰ø°È©¨ËäÇËØùÁ±≥Êï¥Á©∫ÂÖÉÂÜµ‰ªäÈõÜÊ∏©‰º†ÂúüËÆ∏Ê≠•Áæ§ÂπøÁü≥ËÆ∞ÈúÄÊÆµÁ†îÁïåÊãâÊûóÂæãÂè´‰∏îÁ©∂ËßÇË∂äÁªáË£ÖÂΩ±ÁÆó‰ΩéÊåÅÈü≥‰ºó‰π¶Â∏ÉÂ§çÂÆπÂÑøÈ°ªÈôÖÂïÜÈùûÈ™åËøûÊñ≠Ê∑±ÈöæËøëÁüøÂçÉÂë®ÂßîÁ¥†ÊäÄÂ§áÂçäÂäûÈùíÁúÅÂàó‰π†ÂìçÁ∫¶ÊîØËà¨Âè≤ÊÑüÂä≥‰æøÂõ¢ÂæÄÈÖ∏ÂéÜÂ∏ÇÂÖã‰ΩïÈô§Ê∂àÊûÑÂ∫úÁß∞Â§™ÂáÜÁ≤æÂÄºÂè∑ÁéáÊóèÁª¥ÂàíÈÄâÊ†áÂÜôÂ≠òÂÄôÊØõ‰∫≤Âø´ÊïàÊñØÈô¢Êü•Ê±üÂûãÁúºÁéãÊåâÊ†ºÂÖªÊòìÁΩÆÊ¥æÂ±ÇÁâáÂßãÂç¥‰∏ìÁä∂ËÇ≤ÂéÇ‰∫¨ËØÜÈÄÇÂ±ûÂúÜÂåÖÁÅ´‰ΩèË∞ÉÊª°ÂéøÂ±ÄÁÖßÂèÇÁ∫¢ÁªÜÂ§áÁªøÊùÉÁ†Å';
      // –ø–æ –æ–¥–Ω–æ–π –±—É–∫–≤–µ –∏–∑ –∫–∞–∂–¥–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞, –∑–∞—Ç–µ–º –ø–µ—Ä–µ–º–µ—à–∞—Ç—å
      let arr = [];
      for (let i = 0; i < randInt(4, 8); i++) {
        arr.push(ru[randInt(0, ru.length)]);
        arr.push(en[randInt(0, en.length)]);
        arr.push(cn[randInt(0, cn.length)]);
      }
      // –ø–µ—Ä–µ–º–µ—à–∞—Ç—å
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr.slice(0, randInt(4, 10)).join('');
    }

    // –ù–æ–≤—ã–π —Ä–µ–∂–∏–º: —Å–ª–æ–≤–∞ –ª–µ—Ç—è—Ç –∫ –Ω–∞–º –∏–ª–∏ –æ—Ç –Ω–∞—Å
    function renderWordsMode(durationMs) {
      const startTime = performance.now();
      clearPhaseTimer();
      clearFreezeTimer();
      clearShutterTimer();
      clearCounterTimer();
      clearFocusTimers();
      clearCounterVisTimers();
      stopTicking();
      clearSymbol();
      updateHUD();
      setTheme(pick(0.5));
      startTicking();

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }
      requestAnimationFrame(() => { if (layersRoot) layersRoot.style.opacity = '1'; });
      // –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      // –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å—Ç–∞—Ä—ã–µ canvas –∏–∑ —Å–ª–æ—ë–≤
      [back, mid, front].forEach(el => {
        if (el) {
          Array.from(el.querySelectorAll('canvas')).forEach(c => c.remove());
        }
      });
      // canvas –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è
      function createLayerCanvas(parent) {
        const c = document.createElement('canvas');
        c.width = vw;
        c.height = vh;
        c.style.position = 'absolute';
        c.style.left = '0';
        c.style.top = '0';
        c.style.width = '100%';
        c.style.height = '100%';
        parent.appendChild(c);
        return c;
      }
      const canvBack = createLayerCanvas(back);
      const canvMid = createLayerCanvas(mid);
      const canvFront = createLayerCanvas(front);
      
      const nWords = 3; 
      const allWords = [];
      for (let i = 0; i < nWords; i++) {
        const word = mixedLangWord();
        let fontSize;
        if (i === nWords - 1) { // –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–ª–æ–≤–æ –±—É–¥–µ—Ç –æ—á–µ–Ω—å –º–µ–ª–∫–∏–º
            fontSize = rand(14, 22);
        } else {
            fontSize = rand(48, 120);
        }
        
        const direction = pick(0.5) ? 1 : -1; 
        const y = rand(0.2, 0.8) * vh;
        const x0 = vw / 2;
        const moveDistance = rand(vw * 0.1, vw * 0.25); 
        const x1 = vw / 2 + (moveDistance * direction);

        const duration = durationMs;
        const layer = ['back', 'mid', 'front'][i];
        allWords.push({word, fontSize, y, x0, x1, duration, t0: startTime, layer, direction});
      }
      
      const wordsByLayer = {back: [], mid: [], front: []};
      allWords.forEach(w => wordsByLayer[w.layer].push(w));
      
      const isDark = document.documentElement.classList.contains('dark');
      const wordColor = isDark ? '#fff' : '#000';
      
      function setFocus(target) {
        const map = { back, mid, front };
        Object.entries(map).forEach(([key, el]) => {
          if (!el) return;
          el.classList.toggle('focus', key === target);
          el.classList.toggle('unfocus', key !== target);
        });
        const center = document.getElementById('center');
        if (center) {
          center.classList.toggle('focusViz', target === 'mid');
          center.classList.toggle('unfocusViz', target !== 'mid');
        }
      }
      setFocus('mid');
      
      const focusNames = ['mid', 'back', 'front'];
      const nSwitches = Math.max(1, Math.floor(durationMs / 3000));
      let lastFocus = 'mid';
      const switchTimers = [];
      for (let i = 0; i < nSwitches; i++) {
        let next;
        do {
          next = focusNames[randInt(0, 3)];
        } while (next === lastFocus);
        const at = Math.floor((i + 1) * durationMs / (nSwitches + 1));
        switchTimers.push(setTimeout(() => setFocus(next), at));
        lastFocus = next;
      }
      window._focusTimers = switchTimers;
      
      let running = true;
      function drawWords(ctx, words, now) {
        ctx.clearRect(0, 0, vw, vh);
        words.forEach(w => {
          const p = Math.min(1, (now - w.t0) / w.duration);
          const x = w.x0 + (w.x1 - w.x0) * p;
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.font = `bold ${Math.floor(w.fontSize)}px system-ui, Arial, sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = wordColor;
          ctx.fillText(w.word, x, w.y);
          ctx.restore();
        });
      }
      function animate() {
        if (!running) return;
        const now = performance.now();
        drawWords(canvBack.getContext('2d'), wordsByLayer.back, now);
        drawWords(canvMid.getContext('2d'), wordsByLayer.mid, now);
        drawWords(canvFront.getContext('2d'), wordsByLayer.front, now);
        if (now - startTime < durationMs) {
          requestAnimationFrame(animate);
        }
      }
      animate();
      
      const center = document.getElementById('center');
      if (center) {
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        const startCount = Math.max(1, Math.ceil(durationMs / 1000));
        center.innerHTML = `<div><div class=\"title small pulse-small hiddenSoft\" id=\"visionTitle\"> </div><div class=\"counter\" id=\"drawCounter\">${startCount}</div></div>`;
      }
      const counterEl = document.getElementById('drawCounter');
      const titleEl = document.getElementById('visionTitle');
      if (counterEl) {
        let remainingSec = Math.max(1, Math.ceil(durationMs / 1000));
        counterEl.textContent = String(remainingSec);
        counterEl.style.transition = 'opacity 3000ms ease-in-out';
        if (titleEl) titleEl.style.transition = 'opacity 3000ms ease-in-out';
        counterTimer = setInterval(() => {
          remainingSec -= 1;
          if (remainingSec <= 0) {
            clearCounterTimer();
            counterEl.textContent = '0';
          } else {
            counterEl.textContent = String(remainingSec);
          }
        }, 1000);
        
        const visTimers = [];
        setTimeout(() => { counterEl.style.opacity = '1'; if (titleEl) titleEl.classList.remove('hiddenSoft'); }, 0);
        visTimers.push(setTimeout(() => { counterEl.style.opacity = '0'; if (titleEl) titleEl.classList.add('hiddenSoft'); }, 10000));
        if (durationMs > 7000) {
          visTimers.push(setTimeout(() => { counterEl.style.opacity = '1'; if (titleEl) titleEl.classList.remove('hiddenSoft'); }, Math.max(0, durationMs - 7000)));
        }
        window._counterVisTimers = visTimers;
      }
      
      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      freezeTimer = setTimeout(() => { 
          running = false;
          stopTicking();
      }, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }
    
    // –ù–æ–≤—ã–π —Ä–µ–∂–∏–º: –º–∏—à–µ–Ω—å
    function renderTargetMode(durationMs) {
      clearPhaseTimer();
      clearFreezeTimer();
      clearShutterTimer();
      clearCounterTimer();
      clearFocusTimers();
      clearCounterVisTimers();
      stopTicking();
      clearSymbol();
      updateHUD();
      setTheme(pick(0.5));
      startTicking();

      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      const cx = vw / 2;
      const cy = vh / 2;
      const layersRoot = document.getElementById('layers');
      const midLayer = document.getElementById('layerMid');
      clearLayers();
      
      const center = document.getElementById('center');
      if (center) { center.innerHTML = ''; }
      
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', vw);
      svg.setAttribute('height', vh);
      svg.style.position = 'absolute';
      midLayer.appendChild(svg);
      
      if (layersRoot) { 
        layersRoot.style.opacity = '0';
        requestAnimationFrame(() => { layersRoot.style.opacity = '1'; });
      }
      
      const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#000';
      const allTimers = [];
      window._focusTimers = allTimers;
      
      const circles = [];
      let lastRadius = Math.min(vw, vh) * 0.45;
      let lastStrokeWidth = Math.max(4, lastRadius * 0.1);

      // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Å–µ –∫—Ä—É–≥–∏ –∑–∞—Ä–∞–Ω–µ–µ
      const maxSteps = 15; // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
      for (let i = 0; i < maxSteps; i++) {
          if (i === 0) {
              circles.push({ radius: lastRadius, strokeWidth: lastStrokeWidth });
          } else {
              const gap = lastStrokeWidth; 
              const newOuterEdge = (lastRadius - lastStrokeWidth / 2) - gap;
              if (newOuterEdge < 4) break; 

              const newStrokeWidth = Math.max(2, newOuterEdge * 0.1);
              const newRadius = newOuterEdge - newStrokeWidth / 2;
              if (newRadius < 2) break;

              circles.push({ radius: newRadius, strokeWidth: newStrokeWidth });
              lastRadius = newRadius;
              lastStrokeWidth = newStrokeWidth;
          }
      }

      // *** –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ù–æ–≤–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è (chained) –ª–æ–≥–∏–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏ ***
      function processCircle(index) {
        if (index >= circles.length) return; // –í—Å–µ –∫—Ä—É–≥–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω—ã

        const circleData = circles[index];
        const drawDuration = 2800;
        const blurDuration = 1500;
        const pauseBeforeBlur = 1000;

        // 1. –†–∏—Å—É–µ–º —Ç–µ–∫—É—â–∏–π –∫—Ä—É–≥
        const currentCircleEl = document.createElementNS(svgNS, 'circle');
        currentCircleEl.setAttribute('cx', cx.toFixed(1));
        currentCircleEl.setAttribute('cy', cy.toFixed(1));
        currentCircleEl.setAttribute('r', circleData.radius.toFixed(1));
        currentCircleEl.setAttribute('stroke', strokeColor);
        currentCircleEl.setAttribute('stroke-width', circleData.strokeWidth.toFixed(2));
        currentCircleEl.setAttribute('fill', 'none');
        svg.appendChild(currentCircleEl);
        applyDrawAnimation(currentCircleEl, drawDuration, 100);

        // 2. –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫—Ä—É–≥, –ø–ª–∞–Ω–∏—Ä—É–µ–º –µ–≥–æ —Ä–∞–∑–º—ã—Ç–∏–µ –∏ –≤—ã–∑–æ–≤ —Å–ª–µ–¥—É—é—â–µ–≥–æ
        if (index < circles.length - 1) {
          // 3. –¢–∞–π–º–µ—Ä –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–∑–º—ã—Ç–∏—è (–ø–æ—Å–ª–µ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ + –ø–∞—É–∑–∞)
          const blurStartTimer = setTimeout(() => {
            currentCircleEl.style.transition = `filter ${blurDuration}ms ease-in-out, stroke-opacity ${blurDuration}ms ease-in-out`;
            currentCircleEl.style.filter = 'blur(7px)';
            currentCircleEl.style.strokeOpacity = '0.5';

            // 4. –¢–∞–π–º–µ—Ä –¥–ª—è –≤—ã–∑–æ–≤–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∫—Ä—É–≥–∞ (–ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–∑–º—ã—Ç–∏—è)
            const nextCircleTimer = setTimeout(() => {
              processCircle(index + 1);
            }, blurDuration); // –ñ–¥–µ–º –æ–∫–æ–Ω—á–∞–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä–∞–∑–º—ã—Ç–∏—è
            allTimers.push(nextCircleTimer);

          }, drawDuration + pauseBeforeBlur);
          allTimers.push(blurStartTimer);
        }
      }

      // –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–µ–ø–æ—á–∫—É
      processCircle(0);

      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      const doFreeze = () => {
        stopTicking();
        clearFocusTimers();
      };
      freezeTimer = setTimeout(doFreeze, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }


    function renderSymbolFor(durationMs) {
      clearPhaseTimer();
      clearFreezeTimer();
      clearShutterTimer();
      clearCounterTimer();
      clearFocusTimers();
      clearCounterVisTimers();
      stopTicking();
      clearSymbol();
      updateHUD();

      const flipTheme = pick(0.10);
      setTheme(flipTheme);

      const sizeRatio = rand(0.30, 0.90);
      const vw = Math.max(window.innerWidth, 320);
      const vh = Math.max(window.innerHeight, 320);
      const minDim = Math.min(vw, vh);
      const maxScale = 1.25;
      const sizePx = Math.floor(minDim * sizeRatio / maxScale);
      const rotate = 0;
      let left = (vw - sizePx) / 2;
      let top = (vh - sizePx) / 2;

      const layersRoot = document.getElementById('layers');
      const back = document.getElementById('layerBack');
      const mid = document.getElementById('layerMid');
      const front = document.getElementById('layerFront');
      [back, mid, front].forEach(el => { if (el) { el.innerHTML=''; el.classList.remove('focus','unfocus'); } });
      
      if (layersRoot) {
        layersRoot.style.opacity = '0';
        layersRoot.style.transition = 'opacity 800ms ease';
      }

      const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#000';
      function mountTo(layerEl, scale) {
        const wrap = document.createElement('div');
        wrap.className = 'symbolWrapper';
        wrap.style.width = sizePx + 'px';
        wrap.style.height = sizePx + 'px';
        wrap.style.transform = `translate(${left}px,${top}px) rotate(${rotate}deg) scale(${scale})`;
        const svg = createGlyphSVG(sizePx, strokeColor);
        wrap.appendChild(svg);
        layerEl.appendChild(wrap);
        animateGlyph(svg, durationMs);
        return wrap;
      }

      const wrapBack = mountTo(back, 0.8);
      const wrapMid = mountTo(mid, 1.0);
      const wrapFront = mountTo(front, 1.25);

      if (layersRoot) {
        requestAnimationFrame(() => { layersRoot.style.opacity = '1'; });
      }

      function setFocus(target) {
        const map = { back, mid, front };
        Object.entries(map).forEach(([key, el]) => {
          if (!el) return;
          el.classList.toggle('focus', key === target);
          el.classList.toggle('unfocus', key !== target);
        });
        const center = document.getElementById('center');
        if (center) {
          center.classList.toggle('focusViz', target === 'mid');
          center.classList.toggle('unfocusViz', target !== 'mid');
        }
      }
      setFocus('mid');

      const focusPlan = ['mid', 'back', 'front'];
      const extraSwitches = randInt(1, 3);
      for (let i=0;i<extraSwitches;i++) {
        const r = Math.random();
        focusPlan.push(r < 0.5 ? 'mid' : (r < 0.75 ? 'back' : 'front'));
      }
      let spent = 0;
      const switchTimers = [];
      focusPlan.forEach((layerName, idx) => {
        const totalSwitches = focusPlan.length;
        const slice = Math.floor(durationMs / (totalSwitches + 1));
        spent += slice;
        const at = spent + randInt(-500, 500);
        switchTimers.push(setTimeout(() => setFocus(layerName), Math.max(0, at)));
      });
      window._focusTimers = switchTimers;

      startTicking();

      const center = document.getElementById('center');
      if (center) {
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
        const startCount = Math.max(1, Math.ceil(durationMs / 1000));
        center.innerHTML = `<div><div class=\"title small pulse-small hiddenSoft\" id=\"visionTitle\"> </div><div class=\"counter\" id=\"drawCounter\">${startCount}</div></div>`;
      }
      const counterEl = document.getElementById('drawCounter');
      const titleEl = document.getElementById('visionTitle');
      if (counterEl) {
        let remainingSec = Math.max(1, Math.ceil(durationMs / 1000));
        counterEl.textContent = String(remainingSec);
        counterEl.style.transition = 'opacity 3000ms ease-in-out';
        if (titleEl) titleEl.style.transition = 'opacity 3000ms ease-in-out';
        counterTimer = setInterval(() => {
          remainingSec -= 1;
          if (remainingSec <= 0) {
            clearCounterTimer();
            counterEl.textContent = '0';
          } else {
            counterEl.textContent = String(remainingSec);
          }
        }, 1000);
        
        const visTimers = [];
        setTimeout(() => { counterEl.style.opacity = '1'; if (titleEl) titleEl.classList.remove('hiddenSoft'); }, 0);
        visTimers.push(setTimeout(() => { counterEl.style.opacity = '0'; if (titleEl) titleEl.classList.add('hiddenSoft'); }, 10000));
        if (durationMs > 7000) {
          visTimers.push(setTimeout(() => { counterEl.style.opacity = '1'; if (titleEl) titleEl.classList.remove('hiddenSoft'); }, Math.max(0, durationMs - 7000)));
        }
        window._counterVisTimers = visTimers;
      }

      const shutters = document.getElementById('shutters');
      const freezeLead = 2000;
      const doFreeze = () => {
        stopTicking();
        clearFocusTimers();
        const els = symbolWrapper ? symbolWrapper.querySelectorAll('path, line, polyline, polygon, circle') : [];
        els.forEach(el => {
          const computed = getComputedStyle(el);
          const current = computed.strokeDashoffset;
          el.style.transition = 'none';
          el.style.strokeDashoffset = current;
        });
      };
      freezeTimer = setTimeout(doFreeze, Math.max(0, durationMs));
      shutterTimer = setTimeout(() => { if (shutters) shutters.classList.add('active'); }, Math.max(0, durationMs + freezeLead));
      phaseTimer = setTimeout(() => { if (shutters) shutters.classList.remove('active'); startPause(); }, Math.max(0, durationMs + freezeLead + 2000));
    }

    function showSymbol() {
      phase = 'symbol';
      const showMs = randInt(90000, 120001);
      currentDrawMs = showMs;
      phaseEndAt = performance.now() + showMs + 2000 + 2000; // draw + freeze + shutters
      const intro = document.getElementById('intro');
      if (intro) {
        intro.classList.add('hide');
        setTimeout(() => { if (intro && intro.parentNode) intro.parentNode.removeChild(intro); }, 600);
      }
      hasStarted = true;
      
      const r = Math.random();
      if (r < 0.3) { // 30% —à–∞–Ω—Å –Ω–∞ —Ä–µ–∂–∏–º –º–∏—à–µ–Ω–∏
        renderTargetMode(showMs);
      } else if (r < 0.6) { // 30% —à–∞–Ω—Å –Ω–∞ —Ä–µ–∂–∏–º —Å–ª–æ–≤
        renderWordsMode(showMs);
      } else { // 40% –Ω–∞ —Ä–µ–∂–∏–º —Å–∏–º–≤–æ–ª–æ–≤
        renderSymbolFor(showMs);
      }
    }

    function startPause() {
      phase = 'pause';
      updateHUD();
      stopTicking();
      setTheme(true); // —ç–∫—Ä–∞–Ω –ø–∞—É–∑—ã –≤—Å–µ–≥–¥–∞ –±–µ–ª—ã–π
      clearSymbol();
      clearLayers();
      clearPhaseTimer();
      clearFreezeTimer();
      clearCounterTimer();

      const center = document.getElementById('center');
      if (center) {
        center.innerHTML = hasStarted ? `<div class="title large pulse-large">–û—Ç–¥—ã—Ö...</div>` : ``;
        center.classList.remove('unfocusViz');
        center.classList.add('focusViz');
      }

      const pauseMs = randInt(3000, 15001);
      phaseTimer = setTimeout(showSymbol, pauseMs);
    }

    function toggleSound() {
      if (!audioCtx) {
        initAudio();
      } else if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      soundEnabled = !soundEnabled;
      updateHUD();
      requestWakeLock();
    }

    window.addEventListener('click', toggleSound);
    window.addEventListener('touchstart', function(e){ /* –±—ã—Å—Ç—Ä—ã–π –æ—Ç–∫–ª–∏–∫ –Ω–∞ –º–æ–±–∏–ª–∫–∞—Ö */ }, {passive:true});

    window.addEventListener('resize', () => {
      clearTimeout(resizeRaf);
      resizeRaf = setTimeout(() => {
        if (phase === 'symbol') {
          const remaining = Math.max(300, Math.floor(phaseEndAt - performance.now()));
          phaseEndAt = performance.now() + remaining;
          showSymbol(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º —Å –æ—Å—Ç–∞–≤—à–∏–º—Å—è –≤—Ä–µ–º–µ–Ω–µ–º
        }
      }, 120);
    });
    let resizeRaf = null;

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => { /* released */ });
        }
      } catch (e) {
        // –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –∏–ª–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        if (!wakeLock) requestWakeLock();
        if (phase === 'symbol') {
          const remaining = Math.max(300, Math.floor(phaseEndAt - performance.now()));
          phaseEndAt = performance.now() + remaining;
          showSymbol(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º —Å –æ—Å—Ç–∞–≤—à–∏–º—Å—è –≤—Ä–µ–º–µ–Ω–µ–º
        }
      }
    });

    updateHUD();
    setTheme(true);
    setTimeout(showSymbol, 7000);
    requestWakeLock();
  })();
  </script>
</body>
</html>
